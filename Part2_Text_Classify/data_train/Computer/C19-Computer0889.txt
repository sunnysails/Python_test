　自动化学报
ACTA AUTOMATICA SINICA
1997年 第23卷 第3期 vol.23 No.3 1997



RGIA算法的QR分解实现
孟晓风　王行仁
　　摘　要　提出递推辨识算法一般形式(简称RGIA)的QR分解实现方法，并推导出相应的基于HOUSEHOLDER变换的快速递推算法.该算法可用于各种递推辨识算法中，以减小增益矩阵计算的误差积累和传递，提高辨识精度，同时减少了计算所需的运算量.数值仿真结果表明该算法是正确的.
　　关键词　系统辨只，参数估计，QR分解，多变量系统，HOUSEHOLDER变换，快速递推算法.
IMPLEMENTATION OF RECURSIVE GENERAL IDENTIFICATION
ALGORITHM VIA QR DECOMPOSITION
MENG XIAOFENG　WANG XINGREN
(Dept. of Automatic Control, Beijing University of Aero. and Astro. Beijing 100083)
　　Abstract　An implementation method with QR decomposition for recursive general identification algorithm (RGIA) is proposed and a corresponding fast recursive algorithm based on HOUSEHOLDER transformation is developed in this paper. This algorithm can be used in all sorts of identification methods to get better numerical stability and less numerical complexity. Finally, simulation study on this algorithm is made, whitch shows that this implementation method is correct.
　　Key words　 System identification, parameter estimation, QR decomposition, multivariable system, HOUSEHOLDER transformation, fast recuasive algorithm.
　　1　引言
　　递推辨识算法的一般形式描述为［1，2］
(k)=z(k)-(k),　　　　　　　　　　　　　　　　　　　　　(1a)
(k)=(k-1)+K(k)(k),　　　　　　　　　　　　　　　　　　(1b)
K(k)=ρ(k)R-1(k)Ψ(k)－1(k),　　　　　　　　　　　　　　(1c)
(k)=(k-1)+ρ(k)［(k)τ(k)-(k-1)］,　　　　　　　　(1d)
R(k)=R(k-1)+ρ(k)［Ψ(k)－1(k)Ψτ(k)-R(k-1)］,　　　　　(1e)
x(k+1)=A((k))x(k)+B((k))(k),　　　　　　　　　　　　　(1f)
　　　　　　　　　　　(1g)
(k)=［zτ(k),uτ(k)］τ.　　　　　　　　　　　　　　　　(1h)
其中　z(k)∈Rm×1和u(k)∈Rr×1为过程的输入输出数据；(k)∈RN×1表示k时刻的参数估计值；(k),(k)，Ψ(k)和x(k)分别代表k时刻的输出预报值、新息、输出预报值关于参数θ的导数和预报模型的状态变量；ρ(k)是收敛因子；R(k)是Hessian矩阵的近似式；K(k)为增益矩阵；(k)是输出残差ε(k,θ0)协方差的估计值.RGIA算法把解决辨识问题的思想统一起来，归结成输出预报值及其关于参数θ梯度的推导问题，许多递推算法都可以看作它的一种特例.RGIA算法不仅在理论上具有重要意义，而且是算法收敛性分析的有力工具［1,2］.
　　RGIA算法包括四部分内容：1)计算输出预报误差(k)；2)计算增益矩阵K(k)；3)修正参数估计值；4)计算输出预报值(k)及其关于θ的梯度.这里1)―3)的计算所涉及的前5个式子具有固定的结构形式，与具体所用的模型类无关，因此可以看作一般的数值计算问题进行研究.其中增益矩阵K(k)的计算是RGIA算法的关键，它涉及到矩阵(k)和R(k)的求逆运算，这给算法的实现带来困难.为了解决这一难题，就要设法给出不含矩阵逆运算的等价形式.通常采用的方法是利用矩阵反演公式，将(1c)―(1e)式化成另一种不含矩阵逆运算的等价形式(简称RCKE)［1］.正如一般辨识递推算法那样，RCKE算法中P(k)的计算误差会出现累积、传递现象，尤其是参数个数较多时更是如此.
　　本文将讨论RGIA算法的QR分解实现方法，并推导出相应的基于HOUSEHOLDER变换(简称H-变换)的计算公式.
　　2　RGIA算法的QR分解实现原理
　　定义
P(k)=ρ(k)R-1(k), Π(k)=ρ(k)-1(k),　　　　　　　　　　(2)
则(1c),(1d) 和(1e)式可分别改写成
K(k)=P(k) Ψ(k)Π(k)/ρ(k),　　　　　　　　　　　　　　　(3a)
Π(k)=［μ(k)Π－1(k-1)+(k)τ(k)］-1　　　　　　　　　　　　(3b)
P(k)=［μ(k)P-1(k-1)+Ψ(k)Π(k)Ψτ(k)/ρ(k)］-1，　　　　　(3c)
其中　μ(k)=ρ(k-1).(1-ρ(k))/ρ(k).
　　对于k-1时刻的正定矩阵Π(k-1),存在上三角矩阵RΠ(k-1)，使
Π－1(k-1)=RτΠ(k-1).RΠ(k-1).　　　　　　　　　　　　(4)
利用k-1时刻的上三角矩阵RΠ(k-1)和k时刻的新息向量(k)，构造矩阵
FΠ(k)=［λ(k)RτΠ(k-1)｜(k)］τ.　　　　　　　　　　(5)
式中　λ2(k)=μ(k).对于FΠ(k)，存在正交变换阵TΠ(k)，使其上三角化，即
TΠ(k).FΠ(k)=［RτΠ(k)｜O］τ．　　　　　　　　　　　(6)
于是，k时刻的矩阵Π(k)可以表示为
　　　　　　(7)
因此，(3b)式的计算可由(5)―(7)式代替.
　　同理，对P(k-1)有上三角矩阵Rp(k-1)，使
P-1(k-1)=Rτp(k-1)Rp(k-1)．　　　　　　　　　　　　(8)　
利用(6)式的计算结果RΠ(k)和K时刻的输出预报值关于参数θ的导数Ψ(k)，构造矩阵
Φ(k)=Ψ(k)R－1Π(k)/δ(k).　　　　　　　　　　　　　(9)
再利用Φ(k)和k-1时刻的上三角矩阵Rp(k-1)，构造矩阵
Fp(k)＝［λ(k)Rτp(k-1),Φ(k)］τ，　　　　　　　　　　(10)
其中　δ2(k)=ρ(k).则有正交变换阵Tp(k)，使其上三角化，即
Tp(k)Fp(k)＝［Rτp(k)｜O］τ.　　　　　　　　　　　　(11)
将(7)和(8)式代入(3c)式，得
P(k)=［μ(k)Rτp(k-1)Rp(k-1)　　　　　　　　　　　　　　　　　
+Ψ(k)R－1Π(k)R－τΠ(k)Ψτ(k)/ρ(k)］－1.　　　　　(12)
由(9)―(12)式得
　　　　　　(13)
因此，(3c)式的计算可由(9)―（13）式代替.将(7)和(13)式代入(3a)式，并考虑到(9)式，得
K(k)=R-1P(k)R-τP(k)Ψ(k)R－1Π(k)R－τΠ(k)/ρ(k)　　　　　　　
=R-1P(k)R－τP(k)Φ(k)R－τΠ(k)/δ(k).　　　　　　　　　(14)
将(14)式代入(1b)式，得
θ(k)=θ(k-1)+R-1P(k)R-τP(k)Φ(k)R－τΠ(k)(k)/δ(k).　　　　　(15)
综上所述，RGIA算法中(1b)―(1e)式的计算可由(5)，(6)，(9)―（11）和(15)式代替.
　　定理1.在矩阵方程(11)中，若将正交矩阵Tp(k)分块为
　　　　　　　　　　　(16)
其中 G11(k)∈RN×N，G12(k)∈RN×1，G21(k)∈Rm×N，G22(k)∈Rm×m，则各子矩阵块满足
RP(k)＝G-τ11(k)λ(k)R(k-1),　　　　　　　　　　　　　　(17a)
RP(k)＝G11(k)λ(k)Rp(k-1)＋G12(k)Φτ(k),　　　　　　　　(17b)
R－τP(k)Φ(k)＝G12(k).　　　　　　　　　　　　　　　　　(17c)
　　证明.根据分块矩阵求逆公式［1］以及矩阵TP(k)的正交性，有
　　　　　　　　　　　　　　　　　　　　　
　　(18)
式中
A=G11(k)-G12(k)G-122(k)G21(k).　　　　　　　　　　　(19)
由(18)式得
G-τ11(k)=G11(k)-G12(k)G-122(k)G21(k).　　　　　　　　　(20)
由TτP(k)Tp(k)=I得
Gτ11(k)G12(k)+Gτ21(k)G22(k)=0.　　　　　　　　　　　(21)
　　将(16)式分块表达代入(11)式，比较等式两端可得(17b)式，并且
G21(k)λ(k)RP(k-1)+G22(k)Φτ(k)=0.　　　　　　　　　(22)
由(22)式得
Φτ(k)=-G-122(k)G21(k)λ(k)RP(k-1)．　　　　　　　　(23)
将(23)式代入(17b)式，并考虑到(20)式，得
RP(k)＝(G11(k)-G12(k)G-122(k)G21(k))λ(k)Rp(k-1)　　　　　　　
＝G－τ11(k)λ(k)RP(k-1)，　　　　　　　　　　　　　　(24)
(17a)式得证.根据(23)，(17a)和(21)式，有
R－τP(k)Φ(k)=G11(k)R-τP(k-1)［-G-122(k)G21(k)Rp(k-1)］τ　　　　　　　
=－G11（k)Gτ21(k)G－τ22(k)=G12(k).　　　　　　　　　(25)
证毕.
记
e(k-1)=RP(k-1).(k-1),　　　　　　　　　　　　　(26)
v(k)=R-τΠ(k)((k)+Ψτ(k)(k-1))/δ(k),　　　　　　　　(27)
(G11(k)｜G12(k)(λ(k)eτ(k-1)｜vτ(k))=e(k),　　　　　　　(28)
其中　v(k)∈Rm×1，e(k-1) & e(k)∈RN×1.
　　定理2.RGIA算法k时刻数据的参数估计值为
(k)=R-1P(k)e(k).　　　　　　　　　　　　　(29)
　　证明.将(17c)式代入(15)式，得
(k)=(k-1)+R-1P(k)G12(k)R－τΠ(k)(k)/δ(k).　　　　　(30)
将(17b）式代入(30)式，得
(k)=R-1P(k)(RP(k)(k-1)+G12(k)R－τΠ(k)(k)/δ(k))　　　　　　
=R-1P(k)(［G11(k)λ(k)RP(k-1)+G12(k)Φτ（k)］(k-1)　　　　
+G12(k)R－τΠ(k)(k)/δ(k)).　　　　　　　　　　　　　(31)
将(9)式代入(31)式，并考虑到(26)―（28）式，得
　　(32)
证毕.
　　综上所述，RGIA的正交变换递推算法可表示为
(1a)式，　　　　　　　　　　　　　　　　　　　　　　　　　　　　
　　　　　　　　　　　　(33a)
Φ(k)=Ψ(k)R－1Π(k)/δ(k),　　　　　　　　　　　　　　　　(33b)
v(k)=［R－1Π(k)/δ(k)］［(k)+Ψτ(k)(k-1)］,　　　　　　(33c)
　　　　(33d)
(k)=R-1P(k)e(k),　　　　　　　　　　　　　　　　　　　　(33e)
　　　　　　　　　　　（1f)-(1h)式.
初始条件
　　　　　　　　　　　(34)
　　若算法无需加权，取－1(k)=Im，则有R－1Π(k)/δ(k)=I，此时(33*)式可简化为

　　3　RGIA算法的H-变换快速递推算法
　　对于SISO系统，(33d)式中的Φ(k)和(33a)式中的(k)都是向量，直接利用文献［4］提出的H-变换快速递推公式即可实现(33a)和(33d)式中所需的正交变换.
　　对于MIMO过程，为了利用H-变换快速递推公式，向信息阵(λ(k)RP(k-1)｜λ(k)e(k-1))添加新信息(Φτ(k)｜v(k))时，可采用逐行添加方式，具体推导如下所述.
　　定理3.用N×N维分块矩阵
　　　　　　　　　　　　　　　(36)
构造(N+m)×(N+m)维分块矩阵
　　　　　　　　　　　　(37)
其中 In表示n阶单位阵.若T是正交矩阵，则T′也是正交矩阵.
　　证明.显然，由TτT=IN，可推导出T′τT′=Im+N.　　　　　　　　　　　　　　　　证毕.
　　记
　　　　　　　　　(38)
R0（k)=λ(k)RP(k-1);e0(k)＝λ(k)e(k-1).　　　　　　　　(39)
　　定理4.递推算式(33d)中的正交变换TP(k)可用如下的m步正交变换实现，构造(N+1)阶信息阵Fi(k)及相应的正交变换阵Ti(k)为
　　　　　　　　　　(40)
其中　Ri(k)为N阶上三角阵，ei(k)为N维向量，εi(k)为标量.
　　证明.用(40b)式所定义的正交矩阵Ti(k)，按(37)式构造矩阵Tip(k)，并取
Tp(k)=Tmp(k)Tm-1,p(k)…T1p(k).　　　　　　　　　　　(41)
根据定理3及正交矩阵性质，知Tp(k)为正交矩阵.并且，用归纳法可证明
　　　　　　　(42)
其中
ε(k)=［ε1(k),ε2(k),…，εm(k)］τ．　　　　　　　　(43)
证毕.
(40)式中所需的正交变换可直接利用文献［4］提出的H-变换快速递推公式实现.
　　综上所述，MIMO过程的RGIA的正交变换递推算法表示为

初始条件同(33*).
　　4　性能比较
　　当加权阵取(k)=1，且过程为单变量时，几种计算方法的计算复杂性比较，如表1所示.
表1　几种计算增益矩阵或上三角信息阵方法的计算复杂性比较

算　　法运　　算　　量
加、减法乘、除法开方
RCKE算法1.5N2+3.5N1.5N2+4.5N0
U-D分解N3/6+1.5N2+8N/6N3/6+1.5N2+44N/60
本文方法N2＋3NN2＋9N0

　　考虑SISO模型
A(z-1).y(k)=B(z-1).u(k)+B(z-1).w(k),　　　　　　　　　　(45)
其中｛w(k)｝是均值为零的随机不相关噪声序列，且
A(z-1)=1.0+a1z-1+…+anaz-na,
　B(z-1)=b1z-1+b2z-2+…+bnbz-nb,
D(z-1)=1.0+d1z-1+…+dndz-nd.
根据(45)式，可以推导出输出预报值的表达式为
(k｜θ)=hτ(k,θ).θ，　　　　　　　　　　　　　(46)
其中
h(k,θ)=(-y(k-1),…，-y(k-na),u(k-1),…，　　　　　　　　　　　　
u(k-bn),ε(k-1,θ),…，ε(k-nd,θ))τ，　　　　　　　(47)
θ=(a1,…，ana,b1,…，bnb,d1,…，dnd)τ.　　　　　　　　(48)
输出预报值关于参数θ的梯度可写成
ψ(k)=(-zf(k-1),…，-zf(k-na),uf(k-1),…，　　　　　　　　　　　
　uf(k-bn),εf(k-1,θ),…，εf(k-nd,θ))τ，　　　　　　(49)
其中
　　　(50)
输出残差可写成
　　　　　　　　　　(51)
当加权阵取为单位阵时，RGIA算法退化为递推的极大似然法(RML)
　　　　　(52)
相应的正交变换算法表达为(称为RHT-ML)
　　(53)
仿真例.在(45)式中，输入量u(k)采用幅度为1.0的伪随机二进制序列，w(k)的方差为1.0.在RML算法(52)式和RHT-ML算法(53)式中，取递推初值RP(0)=10－6I，P(0)=106I，(0)=0,ψ(0)=0,h(0)=0，遗忘因子取(λ(k)=μ(k))
μ(k)=0.99*μ(k-1)+0.01,μ(0)=0.95.　　　　　　　　　(54)
表2和3分别给出了采用单精度和双精度运算时两种算法的辨识结果比较.结果表明，RML算法对运算的舍入误差十分敏感，用单精度运算(4字节的浮点运算)根本辨识不了参数，而必须采用双精度(8字节的浮点)运算；对于RHT-ML算法，无论是采用单精度或双精度浮点运算，都可获得很好的辨识结果.可见，与RHT算法相比，RHT-ML算法的数值稳定性好、辨识精度高.
表2　采用单精度运算时，RML和RHT-ML两种算法的辨识结果比较

参数(真值)RMLRHT-ML
L=100L=500L=1000L=2000L=100L=500L=1000L=2000
a1(-1.6)-1.3584-1.0060-1.74395.3229-1.2629-1.5423-1.6525-1.5946
a2(1.61)1.41091.57571.8040-22.2281.32471.56591.65051.6033
a3(-0.776)-0.5542-0.5759-0.90192.2523-0.4620-0.7228-0.8271-0.7681
b1(1.2)1.09832.32631.0705-6.18931.06261.20491.23971.1949
b2(-0.95)-0.5459-5.2059-0.376688.404-0.4947-0.8665-1.0346-0.9889
b3(0.2)0.23122.44121.800924.6460.08070.26690.16360.1713
d1(0.1)0.3658-0.23850.2984-0.34950.03790.07770.10410.0939
d2(0.25)0.06910.4781-0.0026-6.22950.15730.22490.19780.2175
d3(0.875)0.32770.95210.0043-2.96930.25740.73460.73620.8200

表3　采用双精度运算时，RML和RHT-ML两种算法的辨识结果比较

参数(真值)RMLRHT-ML
L=100L=500L=1000L=2000L=100L=500L=1000L=2000
a1(-1.6)-1.3638-1.5684-1.5982-1.5998-1.4087-1.5696-1.5989-1.6002
a2(1.61)1.41371.58331.60811.61041.45041.58421.60851.6106
a3(-0.776)-0.5593-0.7452-0.7749-0.7767-0.5998-0.7463-0.7755-0.7770
b1(1.2)1.10021.18821.22971.20951.07161.18751.22931.2095
b2(-0.95)-0.5522-0.9098-0.95380.9514-0.6352-0.9125-0.9551-0.9518
b3(0.2)0.22560.21790.21380.21380.21830.21640.21350.2138
d1(0.1)0.36210.11000.11210.08310.34240.11080.11240.0833
d2(0.25)0.05900.20260.23350.23250.07680.20150.23340.2325
d3(0.875)0.32640.72170.81580.85010.35780.72460.81680.8502

作者简介：孟晓风　1995年在北京航空航天大学获博士学位，现任该校自控系副教授.目前的研究方向是参数估计、容错技术、飞行控制与飞行仿真.
　　　　　王行仁　1955年北京航空学院研究生毕业.现任北京航空航天大学自控系教授、博士导师、国防科工委科技委兼职委员和军用仿真技术专业组副组长.1985年获国家科技进步一等奖.目前的研究方向是飞行控制与飞行仿真、容错技术.
作者单位：北京航空航天大学自动控制系　北京　100083
参考文献
　［1］方崇智，萧德云.过程辨识.北京：清华大学出版社，1989，424―430.
　［2］Ljung L, Soderstron T. Theory and practice of recursive identification, combridge Mass: MIT Press, 1983.
　［3］Ljung S, Ljung L. Error propagation progerties of recursive least squares adaptation algorithms. Automatica, 1985,21:157-167.
　［4］孟晓风，王行仁，黄俊钦.最小二乘估计的Householder变换快速递推算法.自动化学报，1994，20(1)：20―27.
　［5］Bierman G J. Factorization. Methods for Discrete Sequential Estimation, New York: Academic Press, 1977.
收稿日期　1994-12-15
