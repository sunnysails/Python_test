软件学报
JOURN AL OF SOFTWARE
1999年　第10卷　第10期　Vol.10　No.10　1999



关联规则的开采与更新 
周海岩
摘要　对关联规则的增量式更新算法――IUA(incremental updating algorithm)进行了分析,指出其存在的问题,并给出一个改进的算法NEWIUA(new IUA).NEWIUA算法对已存在的和本次更新时新产生的频繁项目集都加以充分的利用,因此,在保证算法有效的同时提高了效率.文章提出了3种关联规则开采的并行算法,并对各算法进行了分析和讨论.
关键词　数据开采,关联规则,增量式更新,频繁项目集,并行算法.
中图法分类号　TP311
Data Mining and Incremental Updating on Association Rules
ZHOU Hai-yan
(Taiyuan Teachers' College Taiyuan 030001)
Abstract　In this paper, the author analyzes the incremental updating algorithm (IUA) on association rules, points out its existing problems, and presents an improved algorithm, NEWIUA (new IUA), which takes full use of already existing and the current updated new frequent itemsets, therefore the efficiency is increased besides guaranteeing the validity of the algorithm. Three parallel algorithms for data mining on association rules are presented, the analysis and discussion on each algorithm are also presented.
Key words　Data mining, association rules, incremental updating, frequent itemsets, parallel algorithm.
　　数据开采(data mining)是数据库中的知识发现KDD(knowledge discovery in databases)的核心步骤,是一种从大规模数据库或数据仓库中提取隐藏的预测性信息的新方法.此方法的提出让人们有能力最终认识数据的真正价值,即数据中潜在的可用信息和知识.数据开采是目前在国际上数据库、数据仓库和信息决策领域最前沿的方向之一,引起了国内外学术界和工商业界的广泛关注.国际上许多研究机构和实验室都在这个领域开展了各种各样的研究.研究的主要目标是发展有关的方法论、理论工具,以支持从大量数据中提取有用的和让人感兴趣的知识、模式和规则.
　　在数据开采的研究领域,对于关联规则开采的研究开展得比较积极和深入.关于关联规则开采的一般对象、主要应用领域及关联规则在实际问题中的含义在文献[1~3]中均有详细叙述,在此不再重述.本文第1节给出了问题的详细描述.第2节指出了IUA(incremental updating algorithm)算法存在的问题,对IUA算法的效率进行了分析,并给出了一种改进算法.第3节提出了3种关联规则开采的并行算法,并进行了相应的分析与讨论.第4节作出总结.
1　问题描述
　　为了使行文方便和完整,将关联规则开采问题的形式化描述如下[1,2].
　　设I={i1,i2,...,im}是m个不同项目的集合,给定一个事务数据库D,其中每一个交易T是I中一些项目的集合,即Tì I.每一个交易T都与一个唯一的标识符TID相联.如果对于I中的一个子集X,有X T,我们就说一个交易T包含X.一条关联规则(association rule)就是一个形如X Y的蕴涵式,其中X,YI,而且X∩Y=φ.X称作规则的前提,Y是结果.
　　一般把一些项目的集合称作项目集.在一个项目集中所含项目的个数称为该项目集的长度,即X为项目集,X的长度│X│=X中项目的个数.对于XI,如果D中包含X的交易数目为s,则称s为X的支持度.若用Support(X)表示X的支持度,则Support(X)=s.关联规则X Y的支持度定义为Support(X Y)=Support(X∪Y),而一个关联规则也有其衡量标准,称其为“置信度”(confidence),定义为Confidence(XY)=Support(X∪Y)/Support(X).关联规则的开采问题就是在D中筛选出所有具有用户指定的最小支持度和最小可信度的关联规则,即这些关联规则的支持度和可信度分别不小于最小支持度和最小可信度.
　　关联规则的开采问题可以分解为以下两个子问题:
　　① 筛选出事务数据库D中所有具有用户指定的最小支持度的项目集(itemset,I的非空子集).具有最小支持度的项目集称为频繁项目集,反之就称为非频繁项目集.
　　② 利用频繁项目集生成所有的关联规则.对每一个频繁项目集A,找出A的所有非空子集a,如果比率Support(A)/support(a)>minconf,就生成关联规则a(A-a).其中minconf为用户指定的最小可信度.
　　由于子问题②相对来说较为容易,因而目前研究的重点集中在第①个子问题上.
2　关于关联规则的增量式更新算法
　　在关联规则开采的过程中,为了发现事先未知的关联规则,用户必然需要通过对最小支持度和最小可信度这两个阈值的不断调整来逐步聚焦到那些真正令其感兴趣的关联规则上去,这将是一个动态的交互过程.因此,迫切需要高效的更新算法来满足用户对较快的响应时间的需求.
　　传统的关联规则的更新问题考虑的是,当基础数据库或数据仓库中数据发生变化时,如何高效地进行规则更新而勿需从头做起,而本文及文献[1]所考虑的是数据库D中数据保持不变,当用户所给定的阈值(主要指支持度)改变时关联规则的更新问题.
　　由于篇幅所限,在此对关联规则增量式更新算法IUA不作详细介绍,详情见文献[1],并且下文中所用符号及其含义除非特别说明,均与文献[1]相同.
2.1 IUA算法存在的问题
　　IUA算法与Apriori算法(见文献[3])的主要区别在于iua_gen函数,但是在iua_gen函数的第2步修剪中,会将Ck3中由L1中的k- 1个项目与L1＂ 中的一个项目所构成的k-项目集和由L1＂中的一个项目与L12 中的k- 1个项目所构成的k-项目集全部修剪掉.这样导致关联规则在更新时会使一些频繁项目集以及一些有效规则开采不出来.
　　例:设数据库D有4次交易为T1={A,B,C},T2={A,B,D},T3={A,D,E},T4={A,B,C,D}.设旧的最小支持度s=3,与之对应的所有频繁k-项目集(即长度为k的频繁项目集)所构成的集合记为Lk(k=1,2,...,m1),这里m1为所有频繁项目集中的最大长度,于是L1={{A},{B},{D}},L2={{AB},{AD}},此时m1=2.
　　设新的最小支持度s￠ =2.用IUA算法来进行关联规则更新得:
　　L1={{A},{B},{D}}, L1＂ ={{C}}, L11=L1, L12=L1＂, L13=φ , L1＇ =L1∪L1＂ , C21=apriori_gen(Lk-11)-Lk=apriori_gen(L11)- L2={{BD}}(此处k=2),C22=apriori_gen(L12)=φ.
　　执行iua_gen函数来求C23,执行iua_gen函数的第1步拼接得C23={{AC},{BC},{DC}},执行iua_gen函数的第2步修剪,取{AC}∈C23,因为{A}是{AC}的k-1=1个元素的子集,但{A}∈L13=φ,则{AC}在C23中被删除,同样地,{BC},{CD}通过iua_gen函数的修剪都将在C23中被删除,最后得C23=φ .于是得L20={{BD}},从而L21=L20∪L2={{AB},{AD},{BD}},因为C22=φ ,C23=φ ,则L22=,L23=φ ,从而得L2＇=L21∪L22∪L23={{AB},{AD}, {BD}},C31=apriori_gen(L21)- L3={{ABD}}(L3=φ),C32=apriori_gen(L22)=φ (因为L22=φ ).
　　执行iua_gen函数第1步拼接得C33={{ABC},{ADC},{BCD}},经iua_gen函数的修剪最后得C33=φ (因为L23=φ ,任取c∈C33,则c的任意一个有两个项目的子集c＇ 均有c＇L23故应在C33中将c删除),于是得L30={{ABD}}.从而L31=L30∪L3={{ABD}},L32=φ (因为C32=φ ),L33=φ (C33=φ ),所以L3＇ =L31∪L32∪L33=L31= {{ABD}}.
　　这样,由IUA算法所得到的数据库D在最小支持度s＇=2下的所有频繁项目集为{{A},{B},{C},{D},{AB}, {AD},{BD},{ABD}},而实际上数据库D在最小支持度s＇=2下的所有频繁项目集为{{A},{B},{C},{D},{AB}, {AC},{AD},{BC},{BD},{ABD},{ABC}},IUA算法没有把频繁项目集{AC},{BC}及{ABC}开采出来.
　　由上例知,IUA算法不能将大量的频繁项目集以及许多有效规则开采出来.故此算法不是关联规则的增量式更新的有效算法.
2.2 IUA算法效率分析
　　基本性质1. 一个频繁项目集的任一非空子集必定也是频繁项目集.
　　① IUA算法与Apriori算法一样主要利用了上述基本性质1.根据这一基本性质可知,对于任一项目i,如果i不是任一j(j<k)项目集的元素,则i一定不是k-项目集的元素,而在IUA算法的第⑥～⑧步(见文献[1])的循环中,每调用一次iua_gen函数,通过该函数的拼接将会使一些已明显不是频繁k-项目集的k-项目集成为候选k-项目集Ck3中的元素,从而给iua_gen函数中的修剪增加运算量,因此增加了算法的时间复杂性.
　　② IUA算法在关联规则更新时,对k-项目集的开采,只是注意到利用已存在的频繁k-项目集的集合Lk,没有注意基于基本性质1在本次更新时,对新产生的频繁(k- 1)-项目集的集合Lk- 1￠ 加以利用.这在IUA算法中对Ck3的产生以及由Ck3来确定Lk3完全能够体现这一点.另一方面,由以上对IUA算法的分析及iua_gen函数存在的问题,于是PIUA算法也将失去其意义.
　　基于上述对IUA算法的分析和讨论,下面给出IUA算法的改进算法.
2.3 增量式更新算法NEWIUA 
　　给定事务数据库D,一个项目集的支持度可以认为就是所有包含该项目集的交易的数目.设旧的最小支持度为s,Lk为数据库D在最小支持度s下对应的长度为k的所有频繁项目集所构成的集合,k=1,2,...,m1,此处m1为所有频繁项目集的最大长度.对于新的最小支持度s＇ ,设Lk＇为对应的所有频繁k-项目集的集合,k=1,2,...,m2,同样地,m2为所有具有最小支持度s'的频繁项目集的最大长度.对于每一个项目集都有一个域count用来保存它的支持度计数.
　　当最小支持度发生变化时,只有两种情况:① s＇ >s,② s＇ <s.对于情况①,文献[1]中已得到较完美的处理,故NEWIUA算法只对情况②作出处理.
　　　NEWIUA算法的基本框架与IUA算法和Apriori算法一致,对k=1,2,...,m2,采用某种策略来生成候选k-项目集的集合Ck,然后扫描数据库来确定Ck中哪些k-项目集是频繁项目集.
　　NEWIUA算法与传统的增量式更新算法不同之处主要体现在以下两点.
　　① 因为有s＇<s,所以,原来所有在旧的最小支持度s下的频繁k-项目集在新的最小支持度s＇ 下仍是频繁k-项目集,因此在每一趟扫描数据库D计算候选k-项目集的支持度计数时,就没有必要对Lk中的项目集重新再计算一次.因此NEWIUA算法在生成候选k-项目集的集合Ck时不含Lk中的项目集,这在下列NEWIUA算法的基本框架描述中的第(1)步、第(8)步和第(8)＇步中能够体现这一点.
　　② NEWIUA算法在生成候选k-项目集的集合Ck时,不但利用了已存在的频繁k-项目集的集合Lk,而且注意到,基于基本性质1对本次更新时新产生的频繁(k- 1)-项目集的集合Lk- 1＇ 加以充分利用.这一点由NEWIUA算法中的第(9)～(12)步来体现.
　　IUA算法的改进算法――NEWIUA算法的基本框架描述如下.
　　记Lk＂=Lk＇ - Lk,Ck为所有候选k-项目集所构成的集合.
　　NEWIUA算法(s＇ <s).
　　(1) C1={all 1-itemsets c of I}- L1
　　(2) for all transactions t∈D do begin
　　(3) Ct=subset(C1,t); 　　/* C1中包含于交易t的候选1-项目集构成Ct */
　　(4) for all candidates c∈Ct do
　　　　　　c.count++; 　　　/* Ct中候选1-项目集的支持度记数加1 */
　　(5) end 
　　(6) L10={c∈C1│c.count3 s＇ }; L1＇ =L10∪L1
　　(7) for (k=2; Lk- 1＇ ≠φ ; k++) do begin
　　(8) Ck=apriori_gen(Lk- 1＇ )- Lk
　　(9) for all itemsets c∈Ck do 　　　/* 对Ck进行修剪 */
　　(10) for all (k- 1)-subset s of c do 
　　(11) if (sLk- 1＇) then
　　(12) delete c from Ck;
　　(13) for all transactions t∈D do begin
　　(14) Ct=subset(Ck,t) 　　　/* Ck中包含于交易t的候选k-项目集构成Ct */
　　(15) for all candidates c∈Ct do
　　(16) c.count++; /* Ct中候选k-项目集的支持度计数加1 */
　　(17) end
　　(18) Lk2 ={c∈Ck│c.conut3 s＇ };Lk＇ =Lk2 ∪Lk;
　　(19) end
　　(20) Answer=∪kLk＇ 
　　我们也可以将上述算法的第(8)步改为如下形式:
　　(8)＇Ck＇ =∪c(c∈Lk- 1＇ );Ck={all k-subset c of Ck＇ }- Lk.
在NEWIUA算法中选用(8)或(8)＇ 要根据数据库D的特点来确定其优劣.
　　在上述算法中,第(1)步用来生成候选1-项目集C1;第(2)～(5)步计算所有候选1-项目集的支持度计数;第(6)步生成新的所有频繁1-项目集;第(8)步生成所有候选k-项目集的集合Ck;第(9)～(12)步对Ck进行修剪;第(13)～(17)步计算所有候选k-项目集的支持度计数;第(18)步生成新的所有频繁k-项目集;第(20)步是结论.
3　关联规则开采的并行算法
　　数据开采问题的主要挑战性在于数据量巨大,因此算法的效率是关键.为了提高数据开采的效率,可有两种途径来解决此问题:一种是产生高效率的算法,另一种是计算机系统结构的改进.在目前的情况下,后者更具有吸引力.于是我们采用多处理机并行计算模型来进行关联规则的开采.所采用的多处理机并行计算模型是这样的:各处理机有各自的内存,事务数据库D储存于一个各处理机都能共享的大外部存储器中.在计算机互连网高度发达,高性能工作站通过局域网互连而构成工作站机群系统的今天,提出以上并行计算模型是很有意义的.
　　以下所提出的各关联规则开采并行算法的基本思想与NEWIUA算法一样.对于k=1,2,...,首先采用某种策略来生成候选k-项目集的集合Ck利用一些技巧对Ck进行修剪,然后扫描数据库确定频繁k-项目集的集合Lk,最后给出结果∪kLk.
3.1 多趟扫描数据库的并行算法
　　当处理机数远小于数据库的项目数时,采用以下的并行算法来进行关联规则开采.不妨设有两台处理机P1,P2.设给定最小支持度为s,关联规则开采的基本框架如下.
　　并行算法1. 
　　处理机P1并行执行如下步骤:
　　(1) C1={ all 1-itemsets s of I }
　　(2) for all transactions t∈D do begin
　　(3) 　Ct1=subset(C1,t) 　　　/* C1中包含于交易t的候选1-项目集构成Ct1 */
　　(4) 　for all candidates c∈Ct1 do
　　(5) 　　　c.count++; 　　　　/* Ct1中候选1-项目集的支持度记数加1 */
　　(6) end
　　(7) L1={c∈C1│c.counts}
　　(8) for (k=3;Lk- 2≠φ ;k=k+2) do begin
　　(9) 　　　C1=∪c (c∈Lk- 2)
　　(10) 　　　Ck={all k-itemsets s of C1 }
　　(11) 　　　for all itemsets c∈Ck do /* 对Ck修剪 */
　　(12) 　　　　for all (k- 2)-subsets s of C
　　(13) 　　　　　if (sLk- 2) then
　　(14) 　　　　　　delete c from Ck;
　　(15) 　　for all transactions t∈D do begin
　　(16) 　　　Ct1=subset(Ck,t) /* Ck中包含于交易t的候选k-项目集构成Ct1 */
　　(17)　　　 for all candidates c∈Ct do
　　(18) 　　　　c.count++;　　/* Ct1中候选k-项目集的支持度计数加1 */
　　(19)　　 end
　　(20)　　 Lk={c∈Ck│c.count3 s}
　　(21) end
　　理机P2并行执行如下步骤:
　　(1) 　C2={all 2-itemsets s of I}
　　(2) 　for all transactions t∈D do begin
　　(3)　　　 Ct2=subset(C2,t) /* C2中包含于交易t的候选2-项目集构成Ct2 */
　　(4) 　　for all candidates c∈Ct2 do
　　(5) 　　　　c.count++; /* Ct2中候选2-项目集的支持度计数加1 */
　　(6) end
　　(7) L2={c∈C2│c.count3 s}
　　(8) for (m=4; Lm－2≠φ ;m=m+2) do begin
　　(9) 　　　C2=∪c(c∈Lm- 2)
　　(10)　　 Cm={all m-itemsets s of C2}
　　(11) 　　for all itemsets c∈Cm do
　　(12) 　　　for all (m- 2)-subsets s of C
　　(13) 　　　　if (sLm- 2) then
　　(14)　　　　　　　delete c from Cm;
　　(15) 　　for all transactions t∈c do begin
　　(16)　　　　 Ct2=subset(Cm,t) 　　　/* Cm中包含于交易t的候选m-项目集构成Ct2 */
　　(17)　　　　 for all candidates c∈Ct2 do
　　(18) 　　　　　　c.count++;　　 /* Ct2中候选m-项目集的支持度计数加1 */
　　(19) 　　end
　　(20)　　　Lm={c∈Cm│c.count3 s}
　　(21) end
　　当P1,P2各自都完成计算后,由其中一台处理机计算Answer=∪kLk,则算法全部结束.
　　并行算法1采用的方法是处理机P1,P2并行执行.P1用来产生所有长度是奇数的频繁项目集,P2用来产生所有长度是偶数的频繁项目集,然后由其中一台处理机计算出最后结果.
　　设数据库D在最小支持度s下所有频繁项目集中最大的长度为m1,则Apriori算法需扫描数据库m1次或m1+1次.这种情况下,在并行算法1中,两台处理机分别并行地扫描数据库最多[m1/2]+1次,故并行算法1与Apriori算法相比,执行效率提高将近1倍.而并行算法1也可以增加处理机的数量,以提高数据开采的速度.但在并行算法1中,并非处理机数量越多越好,这是因为当处理机数量增加时,会将很多根本不可能是频繁项目集的项目集添加到对应的候选项目集中,于是就增加了无谓的计算量.因此,在采用并行算法1进行关联规则开采时,应适当选用处理机数目.
3.2分部分扫描数据库的并行算法
　　设有n台处理机P1,P2,...,Pn,我们可以采用下列并行算法来进行关联规则的开采.
　　并行算法2.
　　(1) 将数据库D均匀地分为n个部分D1,D2,...,Dn;
　　(2) 处理机P1生成I的所有1-项目集构成候选1-项目集的集合C1;
　　(3) 处理机Pj(j=1,2,...,n)并行扫描数据库D的对应部分Dj,计算候选1-项目集的支持度计
　　　　数;
　　(4) 根据各处理机的计算结果,处理机P1计算出所有候选1-项目集的最后支持度计数,并生成
　　　　L1;
　　(5) 循环(k=2;Lk- 1≠φ;k++) do begin
　　(6) 由处理机P1生成候选k-项目集的集合Ck,即Ck=apriori_gen(Lk-1);
　　(7) 各处理机Pj(j=1,2,...,n)并行地扫描数据库D的对应部分Dj ,计算候选k-项目集的支持
　　　　度计数;
　　(8) 根据各处理机的计算结果,处理机P1计算出所有候选k-项目集的最后支持度计数,并生
　　　　成Lk;
　　(9) 循环结束;
　　(10) 处理机P1最后生成Answer.
　　注:各处理机在并行执行时由处理机P1负责同步.
　　并行算法2扫描数据库的趟数与Apriori算法相同,但在每一趟扫描数据库时,由于各处理机分别并行地扫描数据库的一个部分,故从理论上讲,并行算法2扫描数据库的效率是Apriori算法的n倍.即并行算法2比Apriori算法的效率提高了近n倍.
　　本文提出的并行算法2,在当前大规模并行计算机中以及互连网技术高度发展的情况下是一种非常实用和有效的算法.在分布式数据库中进行关联规则的开采,并行算法2也是一种有效的算法.在并行算法2中,扫描数据库以计算项目集的支持度计数的执行效率是非常高的,而此算法所面临的是在并行计算模型中的消息发送与接收的速度问题.若在一个消息发送与接收高效的系统中,利用并行算法2来对数据库(或分布式数据库)进行关联规则的开采则是非常高效的.
3.3 两趟扫描数据库的并行算法
　　设有m台处理机,分别为P1,P2,P3,...,Pm.与数据库D的项目数相等时,一种最简单明了的算法是:处理机Pj(j=1,2,3,...,m)并行地执行如下操作:
　　(1) Cj={all j-subsets s of I}, /* I的所有j-项目集所构成的集合作为候选j-项目集*/
　　(2) 扫描数据库D,计算各候选项目集的支持度计数,
　　(3) Lj={c∈Cj│c.count s}.
　　当所有处理机都完成计算后,由其中一台处理机计算Answer=∪kLk,则算法结束.
　　采用上述算法虽然各处理机并行地扫描一次数据库即可完成关联规则的开采,但是此算法的计算量是非常大的,要计算I的2m- 1个非空子集的支持度.但是若事先已知I的某一项目所构成的集合不是频繁1-项目集,则只计算I的2m- 1- 1个非空子集的支持度,运算量下降了1倍.在实际的关联规则开采时,一般情况下有下列两个特点:① 在由m个项目组成的项目集I中,所有项目构成的1-项目集不可能全是频繁1-项目集.② I中所有项目所构成的m-项目集不可能是频繁项目集.根据上述两个特点,为了减少计算量,我们提出以下并行算法.
　　并行算法3.
　　(1) 各处理机Pj并行地扫描数据库,计算1-项目集{ij}的支持度,最后根据各处理机的计算结果由其中一台处理机确定出L1,并计算C=∪c(c∈L1)或(1)＇由其中一台处理机计算出L1,并计算C=∪c(c∈L1).设L1中频繁1-项目集的数目为mp,则mpm;
　　(2) 各处理机Pj(j=1,2,...,mp- 1)并行执行以下操作:
　　① Cj+1={all (j+1)-subsets s of C}; /* 产生候选(j+1)-项目集 */
　　② 扫描数据库D,计算各候选集的支持度;
　　③ Lj+1={c∈Cj+1│c.counts}; /* 确定频繁(j+1)-项目集 */
　　(3) 由其中一处理机计算Answer=∪kLk.
　　一般情况下,经过并行算法3的第(1)步处理后,在执行算法的第(2)步,各处理机并行执行所产生的候选项目集数目的总和要比2m- 1少得多.这样,在各处理机分别并行地扫描数据库D以计算各候选项目集的支持度计数时,计算量会大幅度下降,加之并行算法3用于关联规则开采时仅对数据库扫描两次,从而大大提高了关联规则开采的效率.
　　在处理机数量非常多的并行计算模型中,对数据库进行开采时,本文提出的并行算法3是一种高速算法.此算法是以某些处理机执行无用的计算(即计算那些明显不是频繁项目集的支持度)为代价来换取速度的.以机器的数量换取数据开采的速度,这在计算机硬件大幅度降价的今天,也是一种很有意义的方案.
　　本文提出的并行算法3可以有下列两种改进方案.(1) 当处理机数量不增加时,在并行算法3中,当对数据库第2次扫描时,由于有些处理机已处于空闲状态,这时可以让那些空闲的处理机去分担那些计算负荷较大的处理机的计算任务.这需要在算法中采用动态分配处理机的方法.(2) 当处理机数量是项目数量的若干倍时,我们可以将并行算法2和并行算法3结合起来,将数据库分为若干部分,每一部分利用并行算法3进行项目集的支持度计算.
　　对于本文提出的关联规则开采并行算法,都可以根据本文提出的关联规则更新算法NEWIUA中所提供的方法,修改成效率较高的关联规则更新的并行算法.
4　结束语
　　大量数据的产生和收集导致了信息爆炸,要从中发现有价值的信息或知识,达到为决策服务的目的,成为非常艰巨的任务.数据开采方法正是为此目的而提出的.
　　数据开采所面对的是大型数据库或大型数据仓库,其任务是从海量数据中挖掘有价值的信息或知识.因此,数据开采所面临的最大的挑战是计算效率问题,解决这一问题的途径是产生高效的数据开采算法与并行处理,而两者之间的结合更具有引吸力.也就是说,随着现代社会的信息量的急剧增长,迫切需要高效的并行数据开采算法的产生.
注释：本文研究得到国家自然科学基金和太原师范专科学校科研基基金资助。
作者简介：周海岩：1957年生,讲师,主要研究领域为数据开采，信息存储，计算机算法，数据库理论
作者单位:太原师范专科学校 太原 030001
参考文献
1　冯玉才,冯剑琳.关联规则的增量式更新算法.软件学报,1998,9(4):301～306
　(Feng Yu-cai, Feng Jian-lin. Incremental updating algorithms for mining 
　　association rules. Journal of Software, 1998,9(4):301～306)
2　胡侃,夏绍玮.基于大型数据仓库的数据采掘:研究综述.软件学报,1998,9(1):53～63
　(Hu Kan, Xia Shao-wei. Large data warehouse-based data mining: a survey. Journal 
　　of Software, 1998,9(1):53～63)
3　Agrawal R, Srikant R. Fast algorithms for mining association rules. In: 
　　Proceedings of the 20th International Conference on Very Large Databases. 
　　Santiago, Chile, 1994. 487～499
收稿日期:1998-08-10修稿日期;1998-10-14
