软件学报
JOURNAL OF SOFTWARE 
1999年 第10卷 第5期 Vol.10 No.5 1999



在数据库中发现具有时态约束的关联规则
< 
欧阳为民　蔡庆生
摘要　 目前,国际上的关联规则研究尚未考虑时间因素.然而,时间是现实世界的固有属性,许多现实 世界数据库都存在时态语义问题.该文考察称为有效时间的时态约束问题,提出了时间区间延 展与归并技术以及新的时态关联规则发现算法,从而进一步推广了关联规则的应用.
关键词　知识发现,关联规则,时态约束.
中图法分类号　TP311
　　Discovery of Association Rules with Temporal Constraint in Datab ases
　OU-YANG Wei-min1,2　CAI Qing-sheng2
1（Computing Center　Anhui University　Hefei　230039 ）
2　（Department of Computer Science　University of Science and Technolo gy of China　Hefei　230027）
Abstract　　Time has not been taken into account in the current international researches of association rules. However, time is an inherent property in the real world. Ther e exists temporal semantics in many real world databases. The temporal constrain t problem called valid time is considered in this paper. Both the methods for ex tending and merging time intervals and the new discovery algorithm for temporal association rules are proposed. Thus, the application of association rules h as been further generalized.
　　在数据库中发现知识(knowledge discovery in databases,简称KDD),亦称为数据发掘( data mining),是当今国际上人工智能和数据库研究方面最富活力的新兴领域.其目标是为了 满足用户目标,自动处理大量的原始数据,从中识别重要和有意义的模式,并将其作为知识加 以表达［1,2］.由于其强大的应用潜力以及广泛可用的存在于各种数据库中的大量数 据,因此,KDD成为一个具有迫切现实需要的很有前途的热点研究课题［1］.
　　关联规则是美国IBM Almaden Research Center的Rakesh Agrawal等人于1993年首先提 出的KDD研究中的一个重要课题［2］.所谓关联规则是这样一个逻辑蕴涵式:X→Y, 其中X和Y是两个不同的属性集.关联规则的直观含义是对数据库中的所有元组,如果X中的属 性值为真,那么Y中的属性值也为真.例如,计算机系30%的学生是安徽籍,而数据库中有2%的 学生是计算机系且是安徽籍.这里,30%为关联规则的信任度,而2%为关联规则的支持度.我们 所要发现的关联规则应满足用户指定的最低支持度和最低信任度约束.关于关联规则的发现 问题,目前已有若干高效算法［3,4］.
　　在实践中,由于时间是现实世界数据库本身固有的因素,所以在数据中常常会发现时态语 义问题.时态数据的出现使我们有必要在知识发现过程中考虑时间因素.在现实世界数据库中 可以发现各种各样的时态数据,例如,超市的交易记录有时间标记、病员的病历数据记录、天 气数据日志文件等等.我们这里考察的时态语义是所谓的时态约束问题,即如果数据库中的每 个元组均有其有效时间,那么在数据库中所发现的知识也必然有相应的时态约束,以表明所发 现的知识何时是有效的.目前,规则事实上都是假定永远有效的.在这种情况下,没有任何东西 表明规则何时变得有效,何时又被认为无效.同样,目前无效的规则也没有说明它在过去或将 来是否有效.在现实中,附加上某种时态约束的规则将可以更好地描述客观现实情况,因而也 会更有价值.在现实生活中往往存在或希望带有时态约束的规则,我们称这种关联规则为时态 关联规则.
　　本文第1节给出问题描述.第2节简要描述关联规则发现算法的主要思想.第3节提出发现 时态关联规则的有关技术,并给出相应的算法描述.第4节是实验结果.最后是结论与进一步研 究方向.
1　问题描述
　　为了讨论的方便,我们采用关系型数据模型.不过,只需对我们在本文所提出的方法稍加修改 即可应用于其他数据模型,如扩展的关系模型、面向对象的数据模型.令R={I1,I2,...,I m}是一值域为{0,1}的属性集(也称为项目集).与知识发现任务相关的数据集r={t1,t2 ,...,tn}是定义在关系模式{I1,I2,...,Im}上的一个关系,即元素个数为m的二元向 量的集合.
　　我们称某元组t支持(support)某属性A,如果元组t直接包含属性A,或者属性A是元组t的 某个属性值的先辈,记为t［A］=1.令XR是属性子集,t∈r是关系的某一行或元组.如果对每 个属性A∈X均有t［A］=1,那么我们称t支持X,记t［X］=1.与属性集X匹配的元组集记为supp ort(X)={t∈r|t［X］=1}.关系r中的广义关联规则形如X→Y,其中XR,YR＼X.设最低信任 阈值(minimum confidence threshod)和最低支持阈值(minimum support threshod)分 别为γ和σ,如果有|support(X∪Y)|≥σn且|support(X∪Y)|/|support(X)|≥γ,我们称关 系r关于最低信任阈值γ和最低支持阈值σ满足关联规则X→Y.这就是说,关系r中至少有σn 行元组对X和Y中的所有属性均为1,且在对属性集X为1的元组中有比例为γ的元组对属性集Y 也为1.对任意给定的属性集X,如果|support(X)|≥σn,其中n为数据库中的元组数,σ为最低 支持阈值,那么我们称X是频繁的.也就是说数据库中至少有比例为σ的元组对属性集X为1.
　　由于时间是现实世界的固有属性,许多信息系统都存在时态语义问题.本文所考虑的时态语义 是所谓的有效时间(valid time),即在某段时间内,某元组是有效的或合法的.这样,我们 在具有有效时间的元组集中发现的关联规则也必然同样具有相应的有效时间,关联规则因而 就有了时效性.为此,我们在对上述问题进行描述的基础上增加了有效时间约束一项,即在关 系模式中增加一个有效时间valid－time属性,规定每个元组均必须附加有效时间valid －time属性.于是,当判断某元组是否支持某属性A时,由于属性A是附加有效时间约束的,所以 ,我们必须首先判断该元组的有效时间是否与属性A的有效时间匹配.只有两者的有效时间是 匹配的,才可以进一步考虑是否支持的问题.也就是说,我们将判断某元组是否支持某属性A的 问题分为两个子问题：(1) 元组的有效时间与属性A的有效时间是否匹配；(2) 未附加有效 时间的普通元组是否支持属性A.对于第2个子问题,我们可以采用任何一种关联规则发现算法 ,如R.Agrawal提出的Apriori算法中的方法.第1个子问题则是本文要解决的问题.
2　关联规则发现算法Apriori简介
　　关联规则的发现可分为如下两个子问题［3］：
　　(1) 寻找所有支持度不低于用户指定的最低支持的属性组合.我们称这种属性组合为频 繁属性序列集；
　　(2) 利用频繁属性序列集生成所期望的规则.基本方法是这样的,比如说ABCD是频繁属性 序列,如果support(ABCD)/support(AB)不低于用户指定的最低信任度γ,那么规则AB→CD成 立.注意,由于ABCD是频繁属性序列,上述规则必定具有用户指定的最低支持.
　　现在,我们简要描述R.Agrawal提出的寻找所有频繁属性序列集的Apriori算法.我们 以该算法作为发现具有时态约束的关联规则的基础.令K-属性序列为具有K个属性的集合,Fr e［K］为频繁K-属性序列的集合,而C［K］为候选K-属性序列(即可能的频繁属性序列)的 集合.Apriori算法需对数据库作多次遍历,每次遍历均由两个阶段构成.第1,利用上次( 第K-1次)遍历所得到的频繁(K-1)-属性序列集Fre［K-1］生成候选K-属性序列集C［K］. 候选生成算法Apriori－gen［3］保证C［K］是所有频繁K-属性序列集的超集 .第2,对数据库作一次遍历,对其中的每个元组确定它支持C［K］中的哪些候选,并在相应候 选的count域中累计支持数.遍历结束后,检查候选集C［K］,确定哪些候选是频繁的,从 而构成频繁K-属性序列集Fre［K］.该算法反复进行,直到Fre［K］为空时为止.
　　已知频繁(K-1)-属性序列集Fre［K-1］,候选生成算法Apriori－gen返回所有频繁K -属性序列集的超集.该候选生成的算法思想是基于这样一个观察：频繁属性序列的任何一 个子集均是频繁的.该候选生成算法也分为如下两步：
　　(1) 链接(join),即Fre［L,K-1］与自己链接生成C［L,K］.
Insert into C［L,K］
Select p.item1,p.item2,...,p.itemk-1,q.itemk-1
From p∈Fre［L,K-1］,q∈Fre［L,K-1］
Where p.item1=q.item1,p.item2=q.item2,...,p.itemk-2=q. itemk-2,p.itemk-1<q.itemk-1,
　　(2) 修剪(prune),删除C［L,K］中的任何一个候选c,如果c中存在一个长度K-1属性子集 不属于Fre［K-1］,即不是频繁的.
　　上述候选生成算法的正确性请参阅文献［2］.
3　带时态约束的关联规则发现算法
　　我们在现有的关联规则发现算法Apriori的基础上进行扩展,以处理数据的时态约束问 题,从而提出时态关联规则的发现算法.在本文的扩展的数据库中,与普通数据库相比,这里的 元组均多了一个属性值为时间区间的有效时间属性,以体现时态约束.与Apriori算法相比,我 们的算法所用的候选生成方法与Apriori－gen大体相同,不同之处在于,当遍历数据库以 进行候选计数时,两个项目序列要匹配,两者的相关有效时间也需可归并.我们的方法是首先 按照一定比例(由用户根据特定的应用领域确定该比例)延展时间区间,然后再按照不同情况 对时间区间进行归并,累计支持数.注意,此时候选的数据结构中除了项目序列域itemset和计 数器域support外,还要增加一个有效时间域valid－time,以表示其有效的时间区间.
3.1　时间区间的延展
　　时间区间的延展是指将其两个端点向外扩张,以期使两个时间区间能够相遇或交叠,然后 再归并为同一个时间区间.其问题在于如何延展时间区间.一种方法是将所有时间区间的两个 端点均向外延伸固定的长度,另一种方法是按一定比例延展时间区间.当采用前一方法时,我 们无法考虑时间区间本身的长度,每个时间区间一律延伸了固定的长度.其结果是,有的区间 可能扩展了20%,而有的区间却可能扩展了100%.于是,与原来较大的时间区间相比,原来较小 的时间区间的细节信息损失较大.这不甚合理.因此,我们采用后者按一定比例延展时间区间 的方法,以使细节信息损失对不同大小的时间区间是均衡的.在时间区间的延展过程中,细节 信息的损失是不可避免的,这与在利用概念层次关系进行推广时细节信息也有损失是一致的. 
　　时间区间的两端点向外延伸的程度由表示时间区间延展程度的推广因子f确定.该推广因 子f的值既可以由算法自动设置,也可在调用本算法时指定.然而,不管怎样,推广因子f的值应 根据特定应用领域凭经验选取.f的值越大,时间区间的延展就越快,结果规则中细节信息的损 失就越多；反之,f越小,时间区间的延展就越慢,结果规则中细节信息的损失就越少,并且由 于因此而需要更多的独立的延展,算法效率就降低了.如果时间区间在时间轴上的分布是稀疏 的,那么在归并时间区间之前要对其作较大的延展.如果时间区间在时间轴上的分布是稠密的 ,那么即使对时间区间作不算大的延展,也很可能引起细节信息的迅速损失.这些问题在确定 推广因子f的值时应认真加以考虑.事实上,由于事先并不知道推广因子f的值多少才是合适的 ,因此,我们一般采取试探性的办法.这样,推广因子f的值若设定得不合适也就在所难免.为了 发现用户真正感兴趣的模式,必然要不断地调整推广因子f的值.
3.2　时间区间的归并
　　给定一项目序列集合,该集合中的所有项目序列的项目集均相同,但各自的有效时间区间 未必相同,我们的目标是将可以归并的时间区间分别合并起来,并累计归并后在同一时间区间 内彼此匹配的项目序列的个数.两个时间区间的归并可按如下4种基本情况分别进行：
　　(1) 区间a与区间b相同,这两个区间自然地可并为一个区间a,且其两个端点不变；
　　(2) 区间a(i,j)与区间b(m,n)相遇,即j=m,这两个区间可由一个新区间c(i,n)替换；
　　(3) 区间a(i,j)与区间b(m,n)交叠,即i〈m,j〉m且j<n,这两个区间可由一个新区间c(i, n)替换；
　　(4) 区间a(i,j)包含区间b(m,n),即i〈m且j〉n,这两个区间归结为一个区间c(i,j).
　　候选项目序列计数的关键不仅在于识别出除了相关的时间区间不同之外,其他各个项目 均彼此匹配的项目序列,而且还在于识别上述各种时间区间之间的基本关系,并予以归并,累 计相互匹配的项目序列的个数.
3.3　带有时态约束的关联规则发现算法描述
　　本节首先给出一个例子来描述具有时态约束的关联规则的发现方法,然后再给出相应的 算法描述.
　　设有如表1所示的事务数据库,其中TID为事务标识符,Itemset为相应事务所包含的项目 子集,Valid－time为相应事务的有效时间,假定推广因子f=1.5.我们的目标是从中发现具 有有关时态的关联规则.发现方法是在Rakesh Agrawal的Apriori算法中结合时间区间的 延展与归并技术.对候选项目序列计数,不仅要识别项目序列是否匹配,而且还要识别相应的 时间区间是否可以归并,由此统计候选项目序列的支持.具体方法如下：
表1　样本事务数据库

TIDItemsetValid－time
100A,C,D［40,70］
200B,C,E［60,90］
300A,B,C,E［90,120］
400B,E［30,50］
500A,B,C［400,500］

　　(1) 频繁1-项目序列集的发现
　　首先以推广因子f=1.5推广数据库D中各事务的有效时间,再以所有的单个项目构成候选 集C1={{A},{B},{C},{D},{E}},遍历数据库,得到各候选项目-时间对的集合： 
　　　　　　Set(A)={(A,［20,105］),(A,［45,180］),(A,［200,750］)}
　　　　　　Set(B)={(B,［30,135］),(B,［45,180］),(B,［15,75］),(B,［200,750］)}
　　　　　　Set(C)={(C,［20,105］),(C,［30,135］),(C,［45,180］),(C,［200,750］)
　　　　　　Set(D)={(D,［20,105］)}
　　　　　　Set(E)={(E,［30,135］),(E,［45,180］),(E,［15,75］)}
　　接着统计各集合中时间区间可彼此归并的元素对个数,该值即为相应元素对的支持.Set(A)中 的两元素对可归并为(A,［20,180］),但与(A,［200,750］)不可归并.因此,(A,［20,180］) 的支持为2.记Set(A)中未能归并的元素对的集合为Rest(A)={(A,［200,750］)},考察它们彼 此是否可归并,由于Rest(A)中仅有1个元素对,所以该元素的支持只能是1,低于最低支持,应 予删除.用同样的方法考察Set(B),Set(C),Set(D)和Set(E)可得(B,［15,180］)的支持为3； (C,［30,180］),支持为3；(D,［20,105］),支持为1；(E,［30,180］),支持为3.取支持不 低于最低支持2的元素对构成频繁1-项目序列集L1={(A,［20,180］),(B,［15,180］),(C ,［30,180］),(E,［30,180］)}.
　　(2) 频繁2-项目序列集的发现
　　根据Apriori－gen候选生成算法,我们由此可导出候选2-项目序列集C2={AB,A C,AE,BC,BE,CE}.遍历数据库,得到各候选项目-时间对的集合：
　　　　　Set(AB)={(AB,［45,180］),(AB,［200,750］)}
　　　　　Set(AC)={(AC,［20,105］),(AC,［45,180］),(AC,［200,750］)}
　　　　　Set(AE)={(AE,［45,180］)}
　　　　　Set(BC)={(BC,［30,135］),(BC,［45,180］),(BC,［200,750］)}
　　　　　Set(BE)={(BE,［30,135］),(BE,［45,180］),(BE,［15,75］)}
　　　　　Set(CE)={(CE,［30,135］),(CE,［45,180］)}
与上述(1)中的方法相同,接着统计各集合中时间区间可彼此归并的元素对个数,该值即为相 应元素对的支持,取支持不低于最低支持2的元素对构成频繁2-项目序列集L2={(AC,［20, 180］),(BC,［30,180］),(BE,［15,180］),(CE,［30,180］)}.
　　(3) 频繁3-项目序列集的发现
　　根据Apriori－gen候选生成算法,我们由此可导出候选2-项目序列集C2={BCE} ,注意,由于项目序列ABC的子序列BC不是频繁的,因而被修剪了.遍历数据库,得到该候选项目 -时间对的集合：Set(BCE)={(BCE,［30,135］),(BCE,［45,180］)}.容易推知,L3={(BCE ,［30,180］)}.
　　由于L3中只有1个元素,不能生成更长的候选,所以算法过程结束.
基于上述例子,我们给出如下算法描述：
　　Algorithm TCAR:带有时态约束的关联规则发现算法
　　Input: (1) DB为定义在R={I1,I2,...,Im,valid－time}之上 的某关系数据库,其中属性Ii的值域为{0,1},valid－time为相关元组的合法时间区 间；
(2) minsup,minconf和f分别为最低支持度、最低信任度和推广因子；
　　Output: 满足最低支持度和最低信任度的时态关联规则.
　　Begin
　　　(1)　L0={1}; /* initialized the L0 */
　　　(2)　for (k=1;Lk-1≠;k++) {
　　　(3)　　if (k==1) then C1=get－all－item(D); /* take all items as C1 */
　　　(4)　　　else Ck=get－candidate－set(Lk-1 ); /* as same as A priori－gen */
　　　(5)　　for each t transaction t in D do {
　　　(6)　　　if (k==1) then generalize the t.valid－time with f;
　　　(7)　　　for each candidate c∈Ck do 
　　　(8)　　　　if (t.itemset matchs c) then Set(c)=Set(c)∪{(c,t.valid －time)}
　　　(9) 　　}
　　　(10) 　for each candidate c∈Ck do
　　　(11) 　　while |Set(c)|＞1 do {
　　　(12) 　　　x=first－element(Set(c));Set(c)=Set(c)-{x};
　　　(13) 　　　while |Set(c)|≥1 do {
　　　(14) 　　　　y=next－element(Set(c));Set(c)=Set(c)-{y};
　　　(15) 　　　　if y can be merged with x /* by the methods described i n 3.2 */
　　　(16) 　　　　　then {x.valid－time=merge(x.valid－time,y.valid－time );
　　　(17) 　　　　　　　　x.support++;}
　　　(18) 　　　　　else Rest(c)=Rest(c)∪{y};
　　　(19) 　　　　}
　　　(20) 　　　if x.support≥minsup then Lk=Lk∪{x};
　　　(21) 　　　Set(c)=Set(c);
　　　(22) 　　　} 
　　　(23) 　　}
　　　(24) Discovered－Rule－set=∪K get－rules(Lk,minconf);
　　End.
4　性能测试
　　为了测试上节所述算法的性能,我们在PC 586/166(32M内存)上用Visual FoxPro1.0实现了该 算法.合成数据的生成方法与IBM Almaden研究中心Rakesh Agrawal教授领导的KDD研究小组 所采用的方法类似(参见http:∥www.almaden.ibm.com/cs/quest/syndata.html#AssocSynDa ta),只是增加了一个有效时间属性.合成事务数据库的生成参数如下：(1) 事务个数D为 200；(2) 事务所含项目集的平均大小T为5；(3) 最大频繁项目序列的平均大小I为 3；(4) 事务数据库中所含项目的个数N为20；(5) 最低支持minsup为10%.为测试算 法的扩放性,我们逐次递增事务个数,从500起,每次递增500,分6次,递增到3500,相应的性能 曲线如图1所示.实验结果表明,该算法设计正确,并具有良好的可扩放性.
5　结论与进一步的工作
　　时间是现实世界的固有属性,许多现实数据库都存在时态语义问题.本文考虑的时态语义 是所谓的有效时间(valid time),即某元组在某时间区间内是有效的.这样,我们在具有有效 时间的数据集中发现的关联规则也必然同样具有相应的有效时间,关联规则因而也就有了时 效性.为此,我们在Rakesh Agrawal提出的Apriori算法的基础上,结合我们提出的时间区间延 展与归并技术,得到新的能够处理具有时态约束的关联规则发现算法.
　　本文所考虑的时态语义单一,仅考虑了时间区间的时态约束问题,下一步将研究其他类型 (如周期性变化)的时态约束问题.
致谢　本文工作得到了国际KDD研究知名学者加拿大Simon Fraster 大学Han Jiawei教授和美国IBM Almaden Research Center的Rakesh Agrawal教授的支 持,他们为笔者提供了有关的研究资料,特此表示感谢.
　
本文研究得到国家自然科学基金和安徽省教委科研基金资助.
作者欧阳为民 ,1964年生,博士,副教授,主要研究领域为KDD,机器学习,人工智能及其应用.
　　　蔡庆生,1938年生,教授,博士生导师,主要研究领域为机器学习,知识发现,人工 智能.
　　　本文通讯联系人：欧阳为民,合肥 230039,安徽大学计算中心
作者单位：欧阳为民（安徽大学计算中心　合肥　230039）
　　　　　　欧阳为民　蔡庆生（中国科学技术大学计算机科学系　合肥　230027）
　　　　　E-mail: oywm@mars.ahu.edu.cn
参考文献
　[1]　Piatetsky-Shapiro G. Discovery, analysis, and presentation of strong rules. In: Piatetsky-Shapiro G, Frawlay W J eds. Knowledge Discovery in Databa ses. Cambridge, MA: AAAI/MIT Press, 1991. 229～238
　[2]　Agrawal R, Imielinski T, Swami A. Mining association rules between sets of items in large databases. In: Proceedings of the 1993 ACM－SIGMOD Internationa l Conference on Management of Data. Washington, DC, 1993. 207～216
　[3]　Agrawal R, Srikant R. Fast algorithm for mining association rules. In: Proc eedings of the 1994 International Conference on Very Large Data Bases. Santiago, Chile, 1994. 487～499
　[4]　Mannila H, Toivonen H, Verkamo A Inkeri. Efficient algorithms for discoveri ng association rules. In: Proceedings of AAAI Work Shop Knowledge Discovery in D atabases. 1994. 181～192
本文1997-11-20收到原稿,1998-05-28收到修改稿
