计算机应用研究
APPLICATION RESEARCH OF COMPUTERS
2000　Vol.17　No.2　P.22-24



面向Agent程序设计中继承机制的研究
路军　王亚东　王晓龙　王　万庆红
摘 要 对面向对象技术在面向Agent程序设计中的应用进行了系统的研究，指出了继承机制在面向Agent程序设计中的应用及目前存在的两个问题，并分析了解决的方法，为今后的研究指明了方向。
关键词 面向对象 可继承性 聚合 类
1 引言
　　对面向Agent程序设计的研究近几年来受到国内外众多专家学者的关注，它们大都是对Shoham提出的Agent0编程语言[4]和面向Agent编程理论[5]的改进和发展，如澳大利亚学者Devindra Weerasooriya等人提出的并发的面向Agent语言[6]，哈尔滨工业大学姚郑博士提出的AOPL语言[8]等。
　　如何改进拍?愿望-意向(BDI)Agent中的面向Agent程序设计是本文讨论的重点。
　　Agent是一个反应的、自治的、内部驱动的实体，置身于变化的不确定的世界里，它们可以感知这个世界并对其作出反应。到目前为止，还没有几例成熟的、大规模的Agent系统的应用，部分原因是由于缺乏成熟的语言和软件工具，但最大障碍是缺乏使系统复杂性得到有效控制的方法。
　　对系统复杂性的管理，历来是大规模嵌入软件系统的设计者们最富挑战性的工作，需要抽象化、构造技术、继承、模块化和其它机制来管理它们的内在复杂性。面向对象技术是当今最前沿的方法论，此方法通过对象(Object)允许抽象，通过类(Class)的分层实现继承。
　　面向对象技术中的对象模型和动态模型表示技术，加以适当的扩充和约束，可以作为面向对象技术用在面向Agent程序设计中的理论基础[3]。
2 面向对象技术中的相关概念
　　面向对象技术尽管已经在各行各业中普遍得到应用，但对面向对象中一些概念的定义还没有一个统一的标准，下面我们描述几个相关概念。
2.1 对象
　　对象是一个实体，包含状态(信息)和可执行的操作(行为)，它既可以检查又可以改变自身的状态。
2.1.1 构造现实世界中的对象
　　在现实世界中，一个对象被认为是相关知识和行为的软件包，是要解决的问题的反映。
　　我们可以把对象想象成能执行某个任务的“小人”，其中装载着“私人的数据”。
2.1.2 对象的封装(Encapsulate)
　　对象分为“内部”和“外部”两部分。信息在对象内部的表示方法是透明的，一个系统中的其它软件不能够直接访问一个对象的“内部”，这就称为封装。一个对象所具有的方法(操作或过程)允许系统中的其它对象查询信息，触发某个动作或者改变某种状态。
2.1.3 封装的好处
　　(1)封装绑定数据和相关过程。
　　(2)由于封装对象的状态由对象自身来维护，所以状态的表示可以随意改变而不影响系统中的其它对象。
　　(3)对象的方法(Method)是透明的，系统的其它部分只需知道接口协议就可以了，没有也不需要知道具体操作是如何完成的。
2.2 类
　　一个类可以看成是对象的一个“工厂”，一个类定义了变量(Variable，也称为属性)和类中所有的方法(Method)。每一个独立的对象都有其自身的变量值，定义方法的代码通过对象共享。
　　类通过聚合(Aggregate)和继承(Inheritance)来达到“重用”。聚合和继承是可重用的两种最一般的形式，可分别描述为“part of”和“is a”的关系类型。给出一个聚合的例子如图1所示。

图1　聚合的一个例子
2.3 继承
　　图2是一个继承的例子，其中从父类中导出的子类符合“is a”关系，DB-File“is a”File；Text-File“is a”File,这和讨论聚合时的“part of”关系有所不同。
　　要区分继承和聚合之间的不同，只要对树结构的任一顶点提问：“这个类的一个对象和它的父亲是同一个类型吗？”，如果回答是肯定的，则是继承关系，否则为聚合关系。

图3　继承的一个例子
3 面向Agent程序设计中继承机制的引入
　　对象、类等面向对象概念在面向Agent程序设计(AOP)中的应用，使得将继承机制集成到AOP中成为可能和必然。Lobel Crnogorac等人已经给出了AOP中有关继承的概念[1]，本节中我们首先给出dMARs系统[2]的编程环境，然后对它的继承机制加以分析，指出引入继承机制后的好处及系统内存在的两个问题。
3.1 引入继承的好处
　　继承使用户可以扩展一个现存的类，增加相应的变量(Variable)和方法(Method)来定义新类。通过共享类间的代码来大幅度地减少系统中代码的数量。
　　在AOP中引入继承有双重的潜在利益：第一，通过代码共享来降低编程的复杂性；第二，继承的引入有助于多Agent系统模型的修改。
3.2 Agent的表示
　　一个Agent族(Family)X是一个三元组<Bx, Gx, Px>。其中Bx是一个信念原子集，每一个信念原子b(v)(b是一个谓词符号，v=(v1, ..., vn),vi是一个项)反映了Agent所获得的环境状态信息；Gx是一个目标集，其中的每个目标描述了此系统所期望的状态。如果g是一个谓词符号，v如前面所定义，目标!g(v)说明一个Agent要达到一种状态，在此状态下g(v)是一个真信念；Px是一个规划集，每个规划指出如何实现一个目标或对某种情况如何作出反应。
　　一个Agent族是一个Agent实例的集合，这些Agent实例具有相同的信念集，达到相同的目标集，使用相同的规划集来达到所有它们的目标。
　　Agent的实例是动态的，运行时才存在的实体，而Agent族是静态的，相当于OOP中类的概念。任何时候一个Agent都包含一个基本信念原子集，发生在Agent周围环境或Agent内部的事件将导致Agent激活自身相应的规划。每一个规划包含激活条件、上下文条件和规划图三部分，可以表示为<Pinv, Pcon, Pgp>。其中激活条件(Invocation)指激活此规划必须发生的事件；事件(Event)是对信念或目标的增减，用+和-分别表示增减操作，于是+b(v)，-b(v)，+!g(v)，-!g(v)都是事件；上下文条件(Context)是一个由信念原子和连接词∧和∨组成的逻辑表达式，上下文条件必须被Agent的基信念原子集所满足，此规划才能执行；规划图(Graph)是一个非循环图，它的有向边是一些子目标和原动作，表示为了达到此目标所必须达到的子目标和原动作。
　　一个Agent族的实例包含一个初始的基本信念集，要实现的目标和Agent族所用的规划。当一个Agent和环境进行交互时，它采纳并提交相应的规划，形成意向。
　　例1.图3中给出了一个Agent族SimplePlane的几个规划，此Agent族用来模拟简单类型的飞机。事件+!landed(base)触发第一个规划，本规划完成在好天气(w(good))和好能见度(v(good))下着陆的任务。此规划的执行蕴含子目标!checkPos(V)，继而触发各自的规划。两个!checkPos(V)规划的选择基于各自的优先权，高优先权的规划先执行，如果失败，则执行下一个规划。规划+rain(V)对环境的变化作出反应，它是在信念rain(V)被加到Agent的信念集中时被触发的。

图3　SimplePlane的规划集
　　下面我们指出当一个简单的继承机制加入到一个诸如dMARs的面向Agent语言时可能出现的问题。在以下内容中，继承完全引用OOP中的概念，因此，一个Agent(相当于OOP中的对象(Object)继承了它的父Agent的所有规划(相当于OOP中的方法(Method))，重定义了一些规划，并且可能加入一些新规划。
4 引入继承机制后存在的问题及解决方法的分析
4.1 行为保留(Preservation)问题
　　Agent和环境之间的交互产生了Agent的行为(Behaviour)。假设已经实现了一个Agent族X，并证明了它能完成一些期望的行为，我们通过继承X并增加一些新的规划来定义一个新Agent族Y。族Y的任意一个实例是否还至少能达到所有族X的实例所能达到的目标(假设放在相同的环境中)？换句话说，我们能否保证Y的一些特性而不需要确切地证明它们。
　　例2.假设SimplePlane的实例在好天气和能见度下都能成功着陆。现在我们考虑一个新的Agent族AdvancedPlane，它在继承了所有SimplePlane的规划的基础之上，增加了一个针对目标!landed(V)的新规划，如图4所示，此规划使Agent在任何天气和能见度下都能着陆。于是我们继承并扩展了SimplePlane，现在我们试图证明Agent族AdvancedPlane能在任何条件下着陆。

图4　AdvancedPlane的规划集
　　而我们甚至不能保证它在好天气和好能见度下着陆，这是因为，如果新的规划比继承的规划具有更高优先权的话，新规划将被首先触发执行，而新规划中可能包含错误，从而引起SimplePlane坠毁。
　　我们注意到，还是有一些继承的特例，确实能保留行为。如在上例中，如果继承的规划比新规划具有更高优先权的话，AdvancedPlane将保留SimplePlane的行为，即它们都能在好天气、高能见度下着陆。我们还可以构造出一些不包含规划的优先权的、更为复杂的例子，结果仍然不能保证行为的保留。而我们认为，在理想情况下，继承机制应当保证行为保留。
4.2 继承异常(Anomaly)问题
　　假设我们已经定义了一个Agent族X，它能完成了一些期望的行为。现在我们想要建立一个特殊的Agent族Y，可以完成X所能完成的所有目标以及一些其它的目标。我们从X中继承所有的规划，同时将不在X中出现的行为通过编写新规划来实现。如果在此情况下，X和Y不能共享代码，我们称为发生了继承异常情况。
　　例3.假设我们定义一个新的Agent族NewPlane，它在继承了所有SimplePlane的规划并增加了一个针对目标!CheckPos(V)的新规划，此规划含有上下文条件(Context Condition) v(poor)，使Agent能在低能见度下检测自身的位置，如图5所示。因此，NewPlane的实例可以在任何能见度、好天气时着陆，然而继承的规划的上下文条件仍然限制Agent只能在好的能见度下才能着陆，因此这些规划必须用新的上下文条件w(good)进行重写。

图5　NewPlane的规划集
　　所以尽管在两个Agent族间还有一些代码可以共享，如对目标+rain(V)和!ChechPos(V)的规划，但可共享代码的数量已经大大减少了。我们甚至还可以构造出没有代码共享的例子。
　　对Agent父亲族的规划的重定义是易错的，耗时的，而且违反了模块化和封装的概念。继承的引入就是为了通过代码共享来解决这一问题的，而继承异常问题大大地减弱了继承的实用性。
4.3 问题解决方法的分析
　　从以上分析可以看出，继承机制引入后，潜在利益是否能够实现主要依赖于继承机制的定义，特别应当注意的是可能发生两类问题：缺少行为的保留和存在继承异常问题。这两个问题相当于系统有效性和完备性的问题，其中行为的保留类似于有效性：只有期望的行为才能被继承机制所演绎；继承异常类似于完备性：所有期望行为都能被继承机制所演绎。缺少行为的保留导致需要对继承的Agent的每一个特性进行证明；而继承异常和继承机制的表达能力密切相关，一个继承异常通常在继承机制不足以提供Agent之间完成相关抽象行为的代码共享时发生。这两个问题能大大减弱继承机制的可用性，解决它们需要更复杂的继承机制的设计。
　　事实上表明，这种方法通常是利弊各半的，设计更复杂的系统可能减少继承异常现象的发生，但同时增加了行为保留的问题。如何设计出能很好地解决这两个问题的继承机制，将是我们今后的主要工作。
5 结束语
　　到目前为止，许多基于BDI结构的面向Agent程序设计系统已经发展起来[7]，相应地，面向Agent的程序设计语言，如AGENT0[4]，也被提出并用于Agent程序设计。然而，很少有人在如何对面向Agent系统进行分析和设计上下功夫。
　　本文对面向对象技术在Agent程序设计中的应用进行了初步地研究，并对AOP中的继承机制加以分析，指出它依然是一种不成熟的技术，对它的研究将是今后BDI Agent发展的主要方向之一。
本项目的研究获得国家“863”高科技项目的资助(项目编号: 863-ZD-06-01)
路军（哈尔滨工业大学计算机科学与工程系 哈尔滨 150001）
王亚东（哈尔滨工业大学计算机科学与工程系 哈尔滨 150001）
王晓龙（Department of Computing The HongKong Polytechnic University）
王（大庆石油管理局 黑龙江大庆 163712）
万庆红（大庆采油二厂 黑龙江大庆 163414）
参考文献
1，L.Crnogorac, A.S.Rao, K.Ramamohanarao. Analysis of Inheritance Mechanisms in Agent-Oriented Programming. In IJCAI-97, Nagoya, Japan, 1997
2，Mark d'Inverno, David Kinny, Michael Luck, and Michael Wooldridge. A Formal Specification of dMARS. Technical Report72, AAII, November, 1997
3，David Kinny, M.Georgeff, and Anand Rao. A Methodology and Modelling Technique for Systems of BDI Agents. MAAMAW'96, 1996
4，Yoav Shoham. AGENT0: a Simple Agent Language and its Interpreter. In Proceedings of the Ninth National Conference on Artificial Intelligence, AAAI-91, pages 704～709, San Jose, CA, 1991
5，Yoav Shoham. Agent-Oriented Programming. Artificial Intelligence, 60(1): 51～92, 1993
6，Devindra Weerasooriya, A.Rao, K.Ramamohanarao. Design of a Concurrent Agent-Oriented Language. In Intelligent Agents: Theories, Architectures, and Languages. LNAI 890. Springer Verlag, 1995
7，路军, 王亚东, 王晓龙. "信念-愿望-意向"Agent的研究与进展. 计算机科学, 1999, 26(2)
8，姚郑, 高 文. 面向Agent的程序设计. 软件学报, 1997, 8(1)
收稿日期：1999年8月11日
