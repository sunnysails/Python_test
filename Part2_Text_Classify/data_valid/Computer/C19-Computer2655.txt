软件学报
JOURNAL OF SOFTWARE
1999年　第10卷　第9期　Vol.10　No.9　1999



一个面向对象数据库系统的TPC-C测试与分析*
于戈　王国仁　王欣晖　郑怀远
摘要　文章介绍了一个著名的在线事务处理系统性能测试标准TPC-C及其在面向对象数据库管理系统Fish上的设计与实现，并基于实验结果对影响数据库系统性能的主要因素进行了验证和分析.
关键词　Benchmark，面向对象数据库系统，TPC-C.
中图法分类号　TP311
Performance Analysis of an Object-oriented Database System with TPC-C Benchmark
YU Ge WANG,Guo-ren WANG,Xin-hui,ZHENG Huai-yuan
(Department of Computer Science and Engineering Northeastern University Shenyang 110006)
Abstract　In this paper, the authors discuss a known on-line transaction processing testing benchmark TPC-C, and its design and implementation on an object-oriented database management system――Fish. Based on the testing results, the evaluation and analysis on the major factors that affect the database system performance are given.
Key words　Benchmark, OODBMS, TPC-C.
　　数据库系统测试标准由于提供了衡量一个数据库系统各方面性能的规范和方法，变得越来越重要［1］.作为新一代的数据库系统，面向对象数据库系统常常被设计成面向复杂应用环境,如工程设计(CAD/CAM)、多媒体数据处理等.各国的大学、机构和组织为测试面向对象数据库系统在这些应用中的性能,已经提出一些著名的测试标准，如Cattell［2］设计的OO1测试标准、美国威斯康星大学设计的OO7［3］测试标准等.许多面向对象数据库系统，如ObjectStore,O2已经完成了这些测试,并基于测试结果对系统作了有益的改进.这些测试标准所模拟的工程应用具有数据类型与结构复杂、大对象、关联查询和批量更新等新的特点，因此，不同于传统的事务处理型应用.
　　随着数据库技术的发展，面向对象数据库系统也被用于在线事务处理之中，尤其是随着低价位、高性能的工作站和PC机的普及，面向对象数据库系统的应用领域变得越来越广泛.但据我们所知，还很少有人对面向对象数据库系统在在线事务处理领域中的性能做过测试.因此，我们选择了TPC-C测试标准对此加以测试.本文以下部分给出了TPC-C测试标准在面向对象数据库系统Fish上的设计与实现，并对测试的结果进行了分析和比较，为构建高性能OLTP(online transaction processing)面向对象数据库系统提出了一些改进建议.文中的被测系统Fish是我们和日本九州大学合作开发的一个运行于Solaris 2.5/(X86，Sparc)或Windows NT平台、基于NOW(network of workstation)/NOPC(network of PC)网络计算环境的分布式面向对象数据库管理系统.Fish系统包括分布式页式对象服务器WAKASHI［4］，符合ODMG 2.0［5］标准，支持持久化对象的C++风格编程语言INADA/ODMG.图1为Fish的系统结构层次.WAKASHI为面向对象数据库的应用提供了存储管理和基于2PC的事务管理，采用Callback(回叫)协议支持事务间(intra-transaction)的数据缓存，在系统内实现了诸如严格两段锁(2PL)、等待图(WFG)、分布式受限等待深度(DWDL)［6］等封锁机制，并支持嵌套事务处理和并行处理.我们采用TPC-C测试标准从两个方面对Fish系统进行了测试:(1) 功能性测试：包括测试商业应用所要求的功能、OLTP所要求的功能、遵守事务的ACID特性的能力、处理大量数据的能力；(2) 性能测试：包括测试OLTP的响应特性、多用户并发操作的性能、操作大数据库的能力.

图1　Fish系统的要层结构
　　本文第1节概要地描述了TPC-C测试标准.第2节论述了TPC-C测试在Fish系统上的设计与实现.第3节对测试结果进行了比较和评价.第4节总结全文.
1　TPC-C概述
　　TPC-C［7］测试标准是TPC(transaction processing performance council)委员会于1992年公布的一个用于衡量在线事务处理系统性能和性能价格比(performance/cost)的测试标准.TPC-C测试标准的主要设计目标是:（1） 模拟包括更新操作和只读操作的多类型事务；（2） 模拟不同特征的事务处理，包括在线式(对响应时间有严格要求)和延时式(对响应时间的要求比较宽松)；（3） 所有事务必须严格符合ACID特性(atomicity,consistency,isolation,durability )；（4） 拥有复杂的数据结构和联系；（5） 采用多样的数据访问方式；（6） 模拟重负载下大数据库上的多用户并发操作.TPC-C测试标准以实际批发商业活动作为其设计模型，此模型如图2所示.

图2　TPC-C的设计模型
　　其中,批发公司(company)拥有许多仓库(warehouse)并提供商品(item)，每个仓库提供其下属10个分店(district)各1 000 000种商品，每个分店为3 000个顾客(customer)提供零售服务.TPC-C测试标准还定义了5种事务：订购(new-order)、付款(payment)、订购情况(order-status)、发货(delivery)、库存情况(stock-level).其中订购、付款、发货等3种事务为更新型事务，订购情况和库存情况是只读型事务，这5种事务代表了由订货、付款、发货到查询顾客订购情况和查询库存情况等组成的一个完整的商业处理过程.在TPC-C测试中，每个仓库有10个运行上述5种TPC-C事务的终端并发地对TPC-C数据库进行操作，每个终端上运行的TPC-C事务都必须满足一定的混合比.这样的运行要持续规定的时间(最少8小时)，记录在此时间段内完成的订购事务数，将测试时间(单位：min.)除以完成的订购事务数,得到TPC-C测试最重要的结果指标MQTh(maximum qualified throughput)，表示平均每分钟完成了多少个订购事务，显然,MQTh的值越大意味着OLTP的能力越高.
2　TPC-C测试的设计与实现
　　本节描述了按照ODMG 2.0标准对TPC-C测试数据库进行的设计和TPC-C测试在NOPC环境下的实现.
2.1　TPC-C测试设计
　　在TPC委员会所提供的TPC-C规范中,TPC-C数据库模型是以关系形式来描述的，不加变换地直接将其应用到面向对象数据库上显然是不合适的.因此，首先我们要将TPC-C规范中传统的关系模型转换成符合ODMG 2.0标准的面向对象模型，然后以面向对象的方法重新设计TPC-C数据库，最后用INADA/ODMG语言实现这一设计.通过对关系模型和ODMG 2.0标准中一些基本成分的相互对应关系的考察，我们定义了映射规则来将关系定义转换为ODMG 2.0定义，如表1所示.
表1　数据库定义的映射规则

关系模型ODMG 2.0模型
表模式类
表外延
元组对象
属性数据成员
数据类型(short,long,float,char,char,vchar,...)字面量(literal) (d-Short,d-Long,d-Float,d-Char,d-String,...)
主关键字关键字
外关键字联系(d-Rel-Ref,...)

　　按照该映射规则,采用如下的步骤将TPC-C测试数据库的关系模式转换成OO模式：
　　(1) 定义9个类来代替TPC-C规范所规定的TPC-C数据库中的9张二维表；
　　(2) 定义类的数据成员来代替相应表中的属性；
　　(3) 定义联系或联系集合来代替相应表中的外关键字；
　　(4) 为每个类定义构造函数和析构函数；
　　(5) 通过对类的概括定义了3个基类，以形成继承层次；
　　(6) 在类的继承层次中对基类进行提炼；
　　(7) 定义每个类的方法接口.
　　经过以上各步，完成对TPC-C测试数据库的OO模式的定义，图3显示了依照ODMG 2.0标准重新设计的TPC-C测试数据库的类关系图.考虑到影响面向对象数据库系统用于在线事务处理应用的因素，我们选择以下两个方面作为测试点. 


图3　类关系图
　　(1) 用户数： 因为每个用户始终保持在活动状态，所以实验中的用户数就相当于多用户编程级(MPL).在并发执行的情况下，不同的MPL值将会导致不同程度的资源竞争和锁冲突，这对事务的吞吐量(throughput)是至关重要的.尽管TPC-C测试规范只需测试10个用户和1个仓库的情况，但在实验中，我们分别对用户数1～10甚至更多的情况都做了测试，目的在于考察不同情况下的性能表现，探索在NOPC环境下，面向对象数据库系统为达到最大事务吞吐量而所能取得的最优MPL值.
　　(2) 不同的死锁检测机制： 许多面向对象数据库系统采用两段锁(2PL)来保证事务并发执行时的可串行性.由于2PL可能会导致死锁，因此,提供死锁检测机制(deadlock detection,简称DD)来检测和解除死锁是十分必要的.但是死锁检测和解除机制会给系统增加额外开销，因此,优化的死锁检测机制对提高系统性能十分重要.为考察不同的死锁检测和解除机制对面向对象数据库系统性能的影响，Fish设计和实现了3种不同的死锁检测和解除机制，分别为基于超时(timeout)［8］、基于事务等待图(wait for gragh,简称WFG)［8］和基于分布式受限等待深度(distributed wait-depth limited,简称DWDL)［6］.基于Timeout的方法是最简单的死锁检测和解除办法.它用超时机制来检测死锁，每当超时后，由它负责重启动被阻塞的事务.超时机制在客户端实现，当客户程序申请锁时被调用，如果申请锁时被阻塞，事务将等待一段时间，等待时间的长度由变量Timeout-limit控制.一旦事务的等待超过等待时间长度，就被认为产生了死锁，该事务将会被终止(abort)，以解除死锁.但这种方法也存在一定的问题，在某些情况下，一个长事务的执行时间会超过Timeout-Limit，于是检测到假死锁，导致在没有死锁发生的时候，长事务执行失败.我们的实验中写锁的Timeout-Limit设为20s，读锁的Timeout-Limit设为10s.基于WFG的方法是一个精确的死锁检测办法.数据库服务端维护一张等待图，有锁申请时，反映申请锁的事务之间等待关系的边将会被插入等待图，对更新后的等待图作死锁检测，确定是否存在死锁，如果检测到死锁，选择死锁环路上某个事务作为“牺牲者”(victim)，发信号(signal)通知它重启动.“最年轻”(执行时间最短的事务)的事务被选为牺牲者.用等待图的方法来检测死锁是正确的，它总能检测到所有死锁的存在.分布式受限等待深度(DWDL)是改进的并发控制方法，被用来减少由于很高的MPL值而引起的数据拥塞(data contention).在基于DWDL的方法中，用限制事务等待深度的策略来预防死锁的发生.类似于基于WFG的方法，数据库服务端维护一张等待图，有锁申请时，反映申请锁的事务之间等待关系的边被插入等待图，对更新后的等待图作事务之间等待深度的检查.如果等待深度大于1，按照一定的策略,选择等待图中的某个事务作为牺牲者，发信号通知它重启动.由于在死锁发生时，事务之间的等待深度总是大于1的，因此,DWDL能够预防死锁的发生，也就是说，DWDL能够检测潜在的死锁.但事实上，当等待深度大于1时，并不是总会有死锁发生，所以说，DWDL可能会导致事务的假重启动(fake restart).
　　在我们的实验中，分别对Timeout，WFG，DWDL这3种方法作了3组实验，每一组实验包括用户数从1～10或更多的TPC-C测试.为评价系统性能，在每一次测试中我们记录如下两个参数:MQTh值和重启动率，即重启动的事务数与总的完成的事务数之比.
2.2　测试环境配置
　　在实验中，我们使用了两台由连接在100M快速以太网交换机上的AMD K6-233 PC机.一台运行数据库服务器，另一台运行远程终端仿真程序，如图4所示.每台PC机的配置为AMD K6-233CPU，64MB内存，4.3GB硬盘.测试代码由INADA/ODMG 1.0和C++编写，使用Sun Workshop 3.0.1C++编译器编译.

图4　测试平台
　　在实验中，TPC-C测试数据库建立在分布式对象服务器WAKASHI运行的PC机上，在另一台PC机上运行的远程终端仿真程序通过telnet远程登录到WAKASHI所在的PC访问数据库.TPC-C测试所要求的终端由X-Window系统的xterm模拟.每个启动的xterm就代表一个用户终端.每一次测试持续8小时.我们编写了Unix shell脚本(shell script)来使所有的xterm在同一时间内运行，并使用了alarm()函数来使测试程序在运行完规定的时间后退出.实验中的TPC-C测试数据库大小为185MB.初始状态时，数据库中的对象个数为：1个仓库(Warehouse)、1 000 000个商品(Item)、10个分店(District)、3 000个顾客(Customer)、1 000 000个库存(Stock)、30 000个历史记录(History)、30 000个订单(Order)、283 998个订货明细(OrderLine)和0个新订单(New-Order).各种不同类型的事务混合比及事务的等待时间(由TPC-C规范规定)见表2.考虑单个用户(MPL=1)时的情况，显然,单用户的MQTh值是与死锁检测机制无关的，取单用户时的MQTh值MQTh(MPL=1)=1.40，按照表2定义的混合比和等待时间得到理想MQTh与MPL的函数关系如下.
MQTh(MPL=i)=MQTh(MPL=1)×i.　　　　　　　　　　　　(1)
由公式(1)可知，假设重启动率为0，在TPC-C数据库只有1个仓库的情况下，1个仓库的10个终端理想的MQTh值为14.0tpmC.
表2　事务等待时间和混合比

事务类型事务混合比等待时间(sec.)
New-Ordern/a30
Payment43.0%15
Delivery4.0%7
Order-Status4.0%12
Stock-Level4.0%7

　　TPC-C的测试过程要求重复做如下4步：(1) 按照预定义的混合比，从5种TPC-C事务中选取1种事务.（2） 在屏幕上显示命令菜单，然后休眠一段时间，休眠时间按TPC-C规范的要求决定，由变量keyingtime控制.（3） 执行所选定的事务，对数据库进行添加、删除、修改等操作.（4） 在屏幕上显示执行结果，然后休眠一段时间，休眠时间按TPC-C规范的要求决定，由变量thinkingtime控制.如前文所述，这5种事务中有3种是更新型事务，再参考表2所述的事务混合比可知，共有92%的TPC-C事务是更新型事务.因此，锁冲突的发生随着用户数的增长而越发频繁. 
3　结果和分析
　　本节给出了3种实验的结果图表及性能分析，表3列出了所有的测试数据，结果曲线如图5所示.
表3　测试结果

　MQTh值重启动率
MPLTimeoutWFGDWDL理想值TimeoutWFGDWDL
11.401.401.381.400.000.000.00
22.602.352.552.800.880.000.00
34.104.103.654.200.651.241.16
45.104.655.055.605.240.880.00
53.956.206.157.008.211.810.36
62.757.707.358.4015.941.472.13
70.958.458.509.8021.903.172.63
80.659.7010.1011.2038.543.543.07
90.5510.6510.7512.6059.473.464.50
100.0311.5011.1514.0061.224.646.90
11　11.8511.2015.40　8.408.82
12　12.4012.1516.80　11.3817.61
13　12.5012.3018.20　13.9317.59
14　13.4513.3519.60　17.5119.82
15　13.1017.5521.00　21.4317.17
16　13.1517.2522.40　28.1721.62
17　18.9515.9523.80　26.0224.15
18　18.55　25.20　30.56　
19　17.32　26.60　29.21　
20　12.40　28.00　51.72　


图5　3种试验的结果曲线
　　(1) 基于Timeout方法的实验与结果.由图5(a)和表3可知，Timeout方法的最大MQTh值为5.10，最小的MQTh值为0.03，MQTh值的峰值出现在用户数为4的时候.在用户数小于4时，由于事务的并发执行度加大,MQTh的值随用户数的增长而递增.这是因为每个TPC-C事务都必须休眠规定的keyingtime和thinkingtime的时间，用户数的增长导致事务的并发执行度加大，事务吞吐量也随着并发执行度的提高而提高.但是当用户数大于4后，MQTh值随用户数的增长而递减，因为这时有更多的事务并发执行，数据的访问冲突加大，由于锁的存在，被阻塞的事务必须等待Timeout-Limit的时间，但此时较高的事务并发执行度导致很多事务在等待了Timeout-Limit的时间后仍旧没有得到锁，于是越来越多的事务被重启动，但这时并不一定发生了死锁.与理论MQTh值相比，在用户数小于4时,实测MQTh值与理想MQTh值比较吻合.这说明当MPL值小于4时，基于Timeout的死锁检测机制能使系统取得很好的性能.从图5(b)可以看出，事务的重启动率随着用户数的增加而增加.在用户数小于4时，重启动率较低，在用户数从5～9的区间，重启动率以平均60%的速度递增.这就是在用户数大于4后，MQTh值急剧下降的原因.用户数大于9时，事务的重启动率反而没有很大的增加，从用户数为9到用户数为10，重启动率仅增加了2%.因为这时不管大部分的死锁有没有被检测出来，在此之前，由于系统负荷过重，大部分事务已经由于超时而被重启动了.当然，我们可以通过延长超时的等待时间Timeout-Limit来提高系统在这种情况下的事务处理量，可这种处理方法会带来负面影响：在用户数较少的情况下，事务的并发执行度会很低，从而阻碍了MQTh值的提高.可见，采用基于Timeout的死锁检测机制要面临一个Timeout-Limit长度的选择问题，而事实上这个长度是很难确定的，因为它与应用系统和负载水平等方面相关.
　　(2) 基于WFG方法的实验与结果.由图5(a)和表3可知，WFG方法的最大MQTh值为18.95，最小MQTh值为1.40，MQTh值的峰值出现在用户数为17的时候，在用户数小于17时，MQTh值随用户数的增长而递增，这也是由于事务的并发执行度加大的缘故.当用户数为17时，MQTh值达到峰值.过了峰值之后，随着用户数的增加，MQTh值开始下降，在19～20用户数区间，MQTh值急剧下降.在用户数小于6的情况下，实测MQTh值与理想MQTh值吻合得较好.从图5(b)可以看出，当用户数小于10时，事务的重启动率非常低，而且在用户数小于19之前增长较缓慢，用户数大于19后，以77%的速度急剧增长.MQTh值和重启动率的变化趋势表明，WFG方法的性能在相当大的一个MPL范围内是平稳增长的.在用户数为16个时的重启动率和在用户数为19个时的重启动率基本上相同，但MQTh值在达到了17个用户时的峰值18.95之后不再随用户数的增加而增加.我们采用了以邻接表储存等待图节点，用拓扑排序检查有向图中环路的死锁检测算法.实验中发现，对任意复杂的含有20个节点的等待图作拓扑排序检查是否存在环路的时间开销为10-1s，要远远小于包括keyingtime和thinkingtime的一个TPC-C事务几十秒的执行时间.因此，尽管由于用户数的增长带来更多的死锁检测开销，但这些开销还不足以使MQTh值在过了峰值之后而急剧下降(MQTh(MPL=17)=18.95而MQTh(MPL=20)仅为12.40).最根本的原因在于资源(CPU、内存、I/O设备)的拥塞，这时的系统资源被多个事务耗尽，已经没有更多的资源可供使用，因而制约了系统性能的进一步提高，18.95是系统在本实验的NOPC环境下所能达到的最大MQTh值.
　　(3) 基于DWDL方法的实验与结果.由图5(a)和表3可知，DWDL方法的最大MQTh值为17.55，最小的MQTh值为1.40，在用户数小于15时，MQTh值随用户数的增长而依次递增，当用户数为15时，MQTh值达到峰值.过了峰值之后，由于数据冲突的加剧，随着用户数的增加，MQTh值逐渐下降.相对于理想的MQTh值，在用户数小于6的情况下，实测MQTh值逼近于理想MQTh值.从图5(b)可以看出，用户数小于10时，事务的重启动率非常低，在用户数为10～12之间时，事务的重启动率以112%的速度急剧增长.在用户数大于12之后，事务的重启动率反而缓慢增长,这说明了基于DWDL的系统性能在重负载的情况下不平稳，也就很好地说明了MQTh值在用户数大于9之后会急剧下降.当用户数为17时，事务的高重启动率导致低的MQTh值.
　　(4) 性能比较.从最大MQTh值角度来看(见图5(a)和表3)，基于WFG方法的最高MQTh值为18.95，基于Timeout方法的最低的MQTh值为5.10，WFG比Timeout高了270%.DWDL的最高MQTh值为17.55，但它的峰值出现在用户数为15时，说明WFG性能较好.从最大重启动率角度来看(见图5(b)和表3)，在用户数为10时，基于Timeout的方法有最高的重启动率61.22，基于WFG的方法有最低的重启动率4.64.基于Timeout的方法比基于WFG的方法高了1200%，比DWDL高了800%.这说明了为什么Timeout不能像WFG和DWDL方法那样获得高吞吐量，其原因是基于Timeout的死锁检测机制不可避免地导致假死锁的存在.按照TPC-C规范，在用户数为10的情况下，WFG获得的最高MQTh值为11.50；Timeout最低仅为0.03；DWDL为11.15，比WFG低3%.WFG的系统性能在这三者之间是最平稳的.
4　结 论
　　本文描述了运行在NOPC环境下的面向对象数据库系统Fish的TPC-C测试实验,包括：TPC-C测试标准的OO设计、在Fish上的TPC-C测试的实现、3种死锁检测机制的性能对比实验、基于事务吞吐量和重启动率的性能分析.我们的测试结果和性能分析包括：在低MPL值的情况下，WFG，Timeout，DWDL的性能都差不多，实验值与理想值吻合得较好.在高MPL值的情况下，WFG，DWDL的性能比Timeout好，Timeout方法是三者中最差的，原因是其事务的重启动率太高.DWDL在用户数为15时出现峰值，而WFG的峰值出现在用户数为17的时候，这说明在重负载下的表现WFG要强于DWDL.
　　如文中第1节所提到的，MQTh值是TPC-C测试中一个很重要的衡量指标，但因为硬件平台对结果影响很大，所以一个体现被测系统价格性能比的指标更能客观地说明问题.正是基于这一点考虑，TPC委员会在TPC-C规范中发布了一个不容忽视的价格性能比指标，它被定义为被测系统的价格除以MQTh值(以美元计)，这个价格包括硬件、软件(操作系统和数据库系统)及其他外设，如UPS等的价格.由表3可知，Fish系统的MQTh值应为11.50tpmC，测试平台的价格计为2 000美元，所得价格性能比为173.91＄/tpmC，在可比性强的价格性能比指标上己接近了世界著名厂商产品的测试指标.例如，运行在有96个AlphaCPU的Compaq AlphaServer8400服务器上的Oracle8.0所表现的价格性能比为139.49＄/tpmC.有关各厂商产品的TPC-C测试结果可以从http://www.tpc.org/new-result网址得到.
　　通过这次TPC-C测试，我们认为，要提高在多用户并发操作情况下的事务吞吐量，关键问题之一就在于通过改进事务调度和封锁机制来使重启动率降低.但由于单台PC的资源局限性，当事务之间的资源竞争加剧，使系统达到资源拥塞点(thrash point)时，任何试图优化或改进事务调度算法和封锁算法以获取更高事务处理能力的努力都将是徒劳的，此时,如果想在不降低系统性能价格比的条件下取得较高的事务处理能力，就必须利用NOPC的并行处理优势.因此,我们下一步的工作将侧重于从以下两方面进行NOPC环境下的并行处理TPC-C测试：(1) TPC-C测试数据库和TPC-C事务的分布化，形成事务间的并行处理;(2) TPC-C事务的并行化，形成事务内的并行和面向对象数据库的并行查询处理. 
*　本文研究得到第6届霍英东青年基金、教育部资助优秀年轻教师基金和辽宁省自然科学基金资助.
本文通讯联系人：于戈，沈阳110006,东北大学计算机科学与工程系
作者简介：于戈，1962年生，教授，博士生导师，主要研究领域为数据库系统理论与技术.
　　　　　王国仁，1966年生，教授，主要研究领域为数据库集成，面向对象数据库，并行数据库，查询处理.
　　　　　王欣晖，1973年生，博士生，主要研究领域为面向对象数据库系统，数据库系统测试，查询处理.
　　　　　郑怀远，1931年生，教授，主要研究领域为数据库理论和技术.
作者单位：东北大学计算机科学与工程系 沈阳 110006，E-mail:{yuge,wanggr}@mail.neu.edu.cn
参考文献：
［1］Jim G. The Benchmark Handbook. 2nd ed., New York: Morgan Kaufmann Publishers, Inc., 1993
［2］Cattell R, Skeen J. Object operations benchmark. New York: ACM Transactions on Database Systems, 1992,17(1):32～49
［3］Carey N J, DeWitt D J, Naughton J F. The OO7 Benchmark. In: Buneman P, Sushil Jajodia eds. Proceedings of SIGMOD, Washington, D.C: ACM Press, 1993. 12～21
［4］Yu Ge, Kaneko H, Bai Guang-Yi et al. Transaction management for a distributed object storage system WAKASHI――design, implementation and performance. In: Gray A, Larson Per-Ake eds. Proceedings of the 12th ICDE, Birmingham, U K: IEEE Computer Society Press, 1996. 380～389
［5］Cattell R et al. The Object Database Standard ODMG 2.0. New York: Morgan Kaufmann Publisher, Inc., 1997
［6］Franaszek P A et al. Distributed Concurrency control based on limited wait-depth. IEEE Transactions on Parallel Distributed Systems, 1993,11(1):1246～1264
［7］Transaction Processing Performance Council(TPC). TPC BenchmarkTM C Standard Specification Revision 1.0. New York: Morgan Kaufmann Publishers, Inc., 1992
［8］Bernstein P A, Hadzilacos V, Goodman G. Concurrency Control and Recovery in Database Systems. Madison: Addison-Wesley Publishing Company, 1987
收稿日期：1998-06-02，修改日期：1998-09-25
