软件学报
JOURNAL OF SOFTWARE
1999年 第2期 No.2 1999



与替换和集合运算有关的错误*
程晓春1,2　姜云飞3
　　摘要　指出在使用归结方法的自动推理文献中,存在于提升引理和删除策略完备性定理证明中,与替换和集合运算有关的几个错误,并予以分析和改正.
　　关键词　归结,替换,合一,集合,删除策略.
　　中图法分类号　TP18
Errors Related to Substitution and Set Operations 
CHENG Xiao-chun1,2　Jiang Yun-fei3 
　　Abstract　　In this paper, some errors related to substitution and set operations in the proof procedures of lifting lemma and the completeness theorem of deletion strategy, which are in the literatures on resolution-based automated reasoning, are pointed out, analyzed, and corrected.
　　Key words　Resolution, substitution, unification, set, deletion strategy.
　　高效推理方法的研究有重要的意义,例如可用于可满足性问题求解.
　　归结原理［1～4］是根据已有子句产生新子句的推理规则.在归结演绎过程中可能产生大量对证明无用的子句.为了提高归结演绎的效率,在生成无用子句后可以用删除策略［1～3］来删除其中的一部分.
　　本文指出在使用归结方法的自动推理文献中,存在于提升引理和删除策略完备性定理证明中,与替换和集合运算有关的几个错误,并予以分析和改正.
1　提升引理证明中的错误
　　Chang等人在文献［1］中第84页和第85页关于提升引理的证明中,使用了如下断言:
“C is a resolvent of C1 and C2. 
　　　　　　　　　　　　　　C=(－{,...,})∪(－{,...,}) 
　　　　　　　　　　　　　　C′=...=(－{,...,})∪(－{,...,}) 
　　　　　　　　　　　　　　and  is more general than .
　　　　　　　　　　　　　　Clearly, C′ is an instance of C.”
这个断言是错误的．
　　反例：
C1={P(y),P(x)},　　　　　　　　　C2={～P(a),Q(a)}, 
　　　　　　　　C′1={P(a),P(x)},　　　　　　　　C′2={～P(a),Q(a)}=C2,
　　　　　　　　r1=r2=1,　　　　　L1==P(x),　　　　　L2==～P(a),
　　　　　　λ=, σ={a/x}(将x替换为a), θ={a/y}(将y替换为a), γ={a/x}(将x替换为a),
　　　　　　　　C=(－{})∪(－{})
　　　　　　　　 =({P(y),P(a) }－{P(a)})∪({～P(a),Q(a)}－{～P(a)})
　　　　　　　　 ={P(y),Q(a)},
　　　　　　　　C′=(－{})∪(－{}) 
　　　　　　　　　　=({P(a),P(a)}－{P(a)})∪({～P(a),Q(a)}－{～P(a)})
　　　　　　　　　　={Q(a)}.
C′不是C的例.
　　错误原因
　　(－{})不等于(C1－{L1}).因此,=η并不能保证(－{})∪(－{})是(－{})∪(－{})的例.如反例所示,当.因此,下C1中与可合一的文字比=下C1中与下C1中与可合一的文字多时,－{}未必是－{}的例.
　　这个断言的错误能说明Chang等人在文献［1］中提升引理的证明是错误的,而不能说明提升引理本身是错误的.事实上,提升引理本身是正确的.1987年,刘叙华和姜云飞在文献［2］中第60页～第63页给出了提升引理的一个修正了的证明.1989年,Leitsch也指出了Chang等人的上述错误［5］.
2　删除策略完备性定理证明中的错误
　　文献［2］中第71页给出删除策略的一种定义:“设S是子句集.下面的子句序列是从S出发推出C的一个演绎,D:C1,C2,...,Ck=C.如果Ci(1≤i≤k)是重言式,或者Ci被某个Cj包含(j<i),则将Ci从这个演绎中删除.我们称对此演绎D实行了删除策略.”
　　文献［2］中第71页给出删除策略的完备性定理.
　　刘叙华和姜云飞在文献［2］第72页,删除策略完备性定理的证明中,有如下几处错误:
　　错误1. 第6～7行：“设C=L1∨～L1∨G,其中G是子句,L1是原子,若C和D的归结文字是C中L1和D中文字～L2,则R(C,D)=Dσ∨Gσ.故DσR(C,D).”
　　DσR(C,D)是正确的,但是R(C,D)=Dσ∨gσ是错误的.
　　反例：
C={P(x),～P(x),P(a)},　　　L1=P(x),　　　　G={P(a)}, 
　　　　　　　　D={～P(a)},　　　　　　　　～L2=～P(a),　　σ={a/x}(将x替换为a),
　　　　　　　　R(C,D)=(Cσ－{})∪(Dσ－{(～L2)σ})
　　　　　　　　　　　=({P(a),～P(a),P(a)}－{P(a)})∪({～P(a)}－{～P(a)})
　　　　　　　　　　　={～P(a)},
　　　　　　　　Dσ∨Gσ={～P(a),P(a)}.
　　显然,R(C,D)=Dσ∨Gσ是错误的.
　　关于DσR(C,D)的改正的证明：
R(C,D)=(Cσ-{})∪(Dσ-{(～L2)σ}) 
　　　　　　　　　　　　　　　=({,～}∪Gσ-{})∪(Dσ-{～}).
因为c中L1和D中～L2是归结文字,显然,～=～.
于是　　　　　　　　　R(C,D)={～Lσ1}∪...∪(Dσ－{～Lσ1})=Dσ∪...
因此　　　　　　　　　　　　　　　　DσR(C,D).
　　错误2. 第15～17行：“设Cη∈D1(应为CηD1),D1=L1∨D′1,D2=～L2∨D′2,其中
D′1,D′2是子句.又设L1和L2的mgu是σ,于是R(D1,D2)=(D′1∪D′2)σ－{,～}.”
　　反例：
L1=L1∨～L1,　　　D2=～L2∨L2. 
设L1和L2的mgu是σ,因此,
　　　　　　　　　　　=,　　　　Ｄ′1=～Ｌ1,　　　　Ｄ′2=Ｌ2,
　　　　　　　　　　　R(D1,D2)=(－{})∪(－{～})={～,},
而　　　　　　　　　　(d′1∪D′2)σ-{,～}={～,}-{,～}=.
　　错误3. 第18～19行：(D2=～L2∨D′2,L1和L2的mgu是σ)“(1) 若L1∈Cη,令Cη=L1∨C′,于是R(Cη,D2)=(C′∪D′2)σ－{,～}.”
　　反例：
Cη=l1∨～L1,　　　　D2=～L2∨L2, 
设L1和L2的mgu是σ.因此
　　　　　　　　　　　=,　　　 C′=～L1,　　　　　　 D′2=L2,
　　　　　　　　　　　R(Cη,D2)=(Cησ－{})∪(－{～})={～,},
而　　　　　　　　　　(C′∪D′2)σ－{,～}={～,}－{,～}=.
　　上述错误没有影响删除策略的完备性,其正确的证明如下：
　　定理1(删除策略的完备性). 设S是不可满足子句集,如果在归结演绎中使用删除策略,则仍然存在从S出发推出空子句□的归结演绎.
　　证明:首先分析s中子句的两个性质.
　　性质1. 设C1为重言式,C1与C2有归结式R(C1,C2),则R(C1,C2)或为重言式,或被C2包含.
　　设C1=L1∨l′1∨G,其中G是子句,L1和L′1为互补对.σ是C1和C2中归结原子的mgu.
　　(1.1) 若C1的L1和C2的l2是归结文字,则
R(C1,C2)=(－{})∪(－{})=({}∪Gσ－{})∪(－{}). 
显然=－{,于是R(C1,C2)=∪....因此,R(C1,C2)被C2包含.
　　若C1的归结文字为L′1,同理可证R(C1,C2)被C2包含.
　　(1.2) 若C1的归结文字不是L1和L′1,则R(C1,C2)={,}∪...,于是R(C1,C2)是重言式.
　　性质2. 若C1包含C2,C3是任一与C2有归结式R(C2,C3)的子句,则或者R(C2,C3)被C1包含,或者C3与C1有归结式R(C1,C3),且R(C1,C3)包含R(C2,C3).
　　设C1ηC2,L2和L3分别是C2和C3中的归结文字,σ是L2和L3中原子的mgu,R(C2,C3)=(－{})∪(－{}).
　　(2.1) 若L2∈,则和C3有归结式R(,C3)=(－{})∪(－{}).因为C2,所以,－{}－{},R(,C3)R(C2,C3).由归结的提升引理［1～3］,存在C1和C3的归结式R(C1,C3),满足(R(C1,C3))λ=R(,C3)R(C2,C3).因此,R(C1,C3)包含R(C2,C3).
　　(2.2) 若L2∈,但是中有文字满足=.设σ下中与L2可合一的文字为,...,,σ下C3中与L3可合一的文字为,...,,L3∈{,...,}.于是=...==,=...=
