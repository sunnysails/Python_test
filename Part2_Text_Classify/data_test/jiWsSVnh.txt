软件学报
JOURNAL OF SOFTWARE 
1999年 第10卷 第5期 Vol.10 No.5 1999



实时数据库系统中的嵌套事务
刘云生　李国徽
摘要　传统的原子事务是由一个平坦数据库操作序列组成的,事务的执行具有ACID(Atomicity, Consistency, Isolation, Durability)特性.然而,在实时应用环境下,这些却不太适用.该文提出了一种支持实时应用的嵌套事务模型,给出了嵌套事务的特性及正确性标准,着重对嵌套实时事务的优先级分派与并发控制协议进行了讨论.
关键词　事务模型,嵌套事务,优先级分派,并发控制,事务正确性, 实时数据库.
中图法分类号　TP311
Nested Transactions in Real-time Database Systems
LIU Yun-sheng　LI Guo-hui
College of Computer Science and Technology Huazhong University of Science and Technology Wuhan 430074
Abstract In the traditional transaction model, a trans action is a flat sequence of the database operations and the executions of trans actions have the ACID(Atomicity, Consistency, Isolation, Durability) properties. But under the real-time environment, these appear unsuitable. A nested transac tion model to support real-time applications is proposed and the properties and the correctness stanadards of nested transactions are presented in this pap er. The priority assignment strategies and the concurrency control protocol for nested real-time transactions are discussed with emphasis.
Key words Transaction model, nested transaction, pri ority assignment, concurrency control, transaction correctness, real-time d atabase.
　　实时应用要求事务能自动监视系统(数据库)的状态及其变迁,在特定情形或时间点触发特定 的活动（事务）.被触发(triggered)的活动按照应用语义的要求可以是触发(triggering)事 务的一个部件、一个独立的事务或触发事务的子事务.这就要求我们提供嵌套事务机制,并给 出嵌套事务处理的调度算法、并发控制协议及事务执行的正确性标准.
　　一般地说,嵌套事务的语义来源主要有以下几个方面:
　　（1） 动态触发的活动按应用要求成为触发事务的子事务;
　　（2） 在分布式应用环境下,一个事务可以划分成若干个代理事务,在不同的节点上分工合作 执行,这些代理事务就是原事务的子事务;
　　（3） 在一些工程应用中,长寿（long-lived）事务或开端（open-ended）事务成为对系 统资源要求的瓶颈.可以把长寿事务或开端事务划分成若干个逻辑上独立的子事务,使占用的 资源能被提前释放;
　　（4） 应用语义在结构上显式地要求一个事务为另一事务的子事务.
1 嵌套事务模型
1.1 嵌套事务
　　在传统的平坦原子事务模型中,一个事务就是一个平淡的操作序列,没有内部结构,具有ACID( Atomicity,Consistency,Isolation,Durability)特性.事务的调度和并发控制满足可串行化 的正确性标准.嵌套事务则不同.
　　定义1. 显式地包含另一事务的事务称为嵌套事务.被包 含者称为子事务,包含者称为其父事务,以p(t1,t2)表示t1为t2的父事务,或用c(t 2,t1)表示t2是t1的子事务.
　　子事务又可包含其自身的子事务.父事务按照同步和异步两种方式触发子事务.在同步方式中 ,子事务被触发执行时,父事务处于等待状态,直到子事务执行完成.在异步方式中,父子事务 同时并发执行.
　　定义2. 在事务的执行过程中触发一个子事务的行为称为事务嵌套事 件,记为NTE.
NTE∷=Eid(〈TID〉,〈SYN〉),
其中Eid为事件标识符,TID为被触发事务的标识,SYN为上面所讨论的触发方式.
　　与一个事务t相联系的所有事务嵌套事件组成的集合称为事务t的事务嵌套事件集,记为NTE t.
　　定义3. 事务t1为t2的祖先事务,记为p*(t1,t2),当且仅 当
p(t1,t2)∨t(p(t1,t)∧p*(t,t2)).
此时,我们也称t2为t1的后代事务,记为c*(t2,t1).
　　定义4. 与一个事务相联的所有事件的事件经历［1］称为该 事务的经历,记为Ht,即
Ht∷=〈Et,＜t〉　EtOEt∪TEt∪CEt∪NTEt∪EEt,
其中＜t为时序关系,OEt为事务的对象事件集,TEt为事务事件集,EEt为外部事件集, CEt为时间事件集［1］,NTEt为事务的嵌套事务事件集.
　　定义5. 设有数据库事务集T,一个事务t∈T称为根事务,当且仅当
　t′∈T(t′≠t∧p(t′,t)).
　　定义6. 设有数据库事务集T,一个事务t∈T称为叶子事务,当且仅 当
　t′∈T(t′≠t∧c(t′,t)).
　　定义7. 对于一个数据库事务集T,t1,t2∈T,当且仅当
c*(t1,t2)∨p*(t1,t2)∨(t∈T(p*(t,t1)∧p*(t,t2),
则称t1,t2位于同一事务家族,记为R(t1,t2).
　　定义8. 设有数据库事务集T,t1,t2∈T,我们称t1,t2互为兄 弟事务,记为S(t1,t2),当且仅当
R（t1,t2）∧!p*(t1,t2)∧!p*(t2,t1).
在嵌套事务模型中,不同事务间可以存在嵌套关系而形成树形结构.图1给出了一嵌套事务t 1,其中r［A］,w［B］分别表示读数据对象A和写数据对象B操作.t1在执行一些读写操作后 同步触发子事务t11,t11执行完之后又异步触发另一子事务t12,而t 11又触发其自身的子事务t111.

1.2 嵌套事务的执行
　　在传统的平坦原子事务中,事务一旦启动,它或者顺利执行完成到提交而把结果反映到数据库 中,或者夭折而不给数据库和外部环境留下任何痕迹.在嵌套事务中,一个子事务的夭折并不 一定要求其父事务夭折,即父事务的执行并不具有原子性,在子事务夭折时,父事务可以作出 如下选择:(1) 重执行该子事务;(2) 执行“替代”/“补偿”事务;(3) 不管该子事务的夭折 ;(4) 父事务夭折.嵌套事务的提交、夭折具有与传统原子事务所不同的语义:
　　(1) 提交规则:一个子事务的提交仅意味着其逻辑操作的完成,其对数据库的更改直到包含该 子事务的根事务提交时才能真正反映到物理数据库.
　　(2) 夭折规则:当一个（子）事务夭折时,其所有的后代事务一定夭折.
　　(3) 可见性规则:一个子事务能访问其祖先事务所持有的数据对象;而在它提交后,它对数据 库的更改可被其父事务访问,但不能被兄弟事务访问.
　　提交规则和夭折规则保证了后面讨论的子事务对父事务的夭折依赖关系,可见性规则及后面 讨论的并发控制协议则保证了数据库的一致性.
　　在传统的原子事务中,一个事务的开始(BEGINt)、提交(COMMITt)和夭折(ABO RTt)与其他事务没有必然的依赖关系,在嵌套事务中,则与其他事务具有相关性.设有父 事务tp,子事务tc,H为它们的经历［1］.
　　 (1) 子事务对父事务存在夭折依赖关系tc AD tp,
tc AD tp:(ABORTtp∈H)(ABORTtc∈H).
　　(2) 子事务对父事务存在开始依赖关系tc BD tp,
tc BD tp:(BEGINtc∈H)(BEGINtp＜tBEGIN tc).
(3) 父事务对子事务存在提交-终止依赖关系tp CD tc,
tp CD tc:(COMMITtp∈H)(ABORTtc＜tCOMMIT tp∨COMMITtc＜tCOMMITtp).
1.3 嵌套事务的正确性
　　嵌套事务正确性的概念及其所涉及的方面较之传统的都更为复杂,在文献［1,2］中对此已有 详细的讨论,它包括:时间正确性、结构正确性、行为正确性及结果正确性.如在文献［1,2］ 中所论述,时间正确性和结构正确性由调度和事务管理通过一定的策略与算法,使事务的时间 相关性和结构依赖性(如上述)得到满足来实现,这相对容易些,不再赘述.这里着重讨论行为 正确性及结果正确性,它由下列“嵌套可串行化”保证.
　　定义9. 设事务集T={t1,t2,...,tn},Dt为t的后代事务集, 称T′={ti1,ti2,...,tim}（m≤n）为T的一个可能执行集,记为T′=PES (T),当且仅当
t∈T(tT′(t′∈Dt(t′T′))).
把一个事务集T执行后,数据库的状态及返回值集分别记为DBS(T)和RV(T),对于任一事务序列 t1,t2,...,tk,它串行执行后的数据库状态及返回值集分别记为DBS(t1,t2,...,t k)和RV(t1,t2,...,tk).
　　定义10. 设有事务集T={t1,t2,...,tn},它的一次执行是嵌套 可串行化的,当且仅当
T′={ti1,ti2,...,tim}T(T′=PES(T)∧DBS(ti1,t i2,...,tim)=DBS(T′)∧RV(ti1,ti2,...,tim)=RV(T′)).
　　事务执行的嵌套可串行化保证了数据库的一致性.下面讨论事务处理如何保证嵌套可串行化. 
2 嵌套实时事务的处理
　　传统事务处理往往没有所谓的调度,事务处理按先来先服务的顺序进行.人们所说的调度,严 格来讲应属于并发控制的范畴,即解决事务对数据资源的竞争.实时事务的处理主要包括优先 级分派、调度与并发控制,一旦优先级分派策略确定了,事务的调度按优先级进行就比较简单 了,故问题的关键是优先级分派策略与并发控制协议的开发.
2.1 子事务的优先级分派
　　在实时数据库系统中,决定事务优先级的关键因素是其截止期.事务的截止期由应用语义或外 部环境的响应时间要求和事务间的时间相关性来决定.采用考虑截止期的事务优先级分派策 略后,每个事务则按优先级竞争CPU时间和其他系统资源.在嵌套事务中,每个（子）事务就 是一个竞争系统资源的单位,这样,就存在一个如何根据根事务的截止期设置其后代事务截止 期,进而分派事务的优先级的问题.
* 统一截止期（SD）
　　该策略的主要思想是基于截止期来分派事务的优先级.事务的优先级不因其嵌套结构而发生 改变,同时,让它所有的后代事务具有与其自身一样的截止期.于是以该事务的名义所进行的 所有子事务在其生命周期中的任何时刻都得到与事务本身相同的优先级.
　　设t为一嵌套事务,则其所有的后代事务具有与它相同的截止期及优先级.即
t′(p*(t,t′)(d(t′)=d(t)∧(pr(t′)=pr(t))),
其中d(t)表示事务t的截止期,pr(t)表示事务t的优先级.
　　* 按比例设置后代事务的截止期
　　该方法的主要思想就是按父事务和子事务所要完成的工作量来设置子事务的“虚拟截止期” .空闲（slack）时间［3］在各事务之间的分配也是按父子事务工作量的比例来 分配.同时,我们也考虑事务的类型（软实时事务、固实时事务、硬实时事务）.我们按如下 公式设置后代事务的“虚拟截止期”:
dv(tc)=min(dg(tc),dg(tp)-Cadj-A).
　　dg(t)是前面讨论的根据用户的设置或外部环境的要求而确定的事务t的截止期.A为事务的 提交延迟或分布式环境下的通信延迟,Cadj是反映父子事务由于对系统资源要求冲突的调整 时间:
　　(a) 如果父子事务异步（并发）执行,且它们对数据资源的访问没有冲突(它们不会由于 数据资源的冲突而互相阻塞),如果子事务能在父事务的截止期之前完成,就不会导致父事务 超过截止期,因此,令Cadj=0;
　　(b) 当① 父子事务异步（并发）执行而它们对数据资源的访问存在冲突;或② 父事务 同步触发子事务.此时,父事务可能被子事务阻塞或父事务必须等待子事务完成.这样,为了让 父事务有足够的时间在其截止期之前完成,子事务最晚完成时间到父事务的截止期之间的时 间应该大于估计父事务还要用的时间.根据父子事务的类型,Cadj有如下的设定:
　　(1) 父子事务均同时为软事务或固事务,父子事务一起分享父事务的空闲时间:
Cadj=ES(s)+sl(tp)*(ES(s)／(ES(s)+ES(tc))).

　　ES(s)表示tp完成触发tc后的那部分工作估计所需要的时间,ES(tc)为估计t c所需要的时间,sl(tp)为tp的空闲时间.
　　(2) tp为软事务,tc为固事务,把tp的全部空闲时间分配给tc,Cadj=ES(s).
　　(3) tp为固事务,tc为软事务,tp的全部空闲时间留给自己,Cadj=ES(s)+sl(tp) .
　　在给事务的各子事务分配了“虚拟截止期”之后,我们可以分配事务的优先级pr(t)=F(dv( t)),然后按优先级进行调度和并发控制.
2.2 并发控制
　　按前面所述的提交规则和可见性规则,结合事务的实时性和嵌套结构特点,我们提出一种按事 务优先级夭折的并发控制协议,其规则是:
　　（1） 当子事务t请求一个已被其祖先事务锁住的数据对象o时,子事务无条件地继承其祖先 事务的锁,而此后至提交前,其祖先事务不能再对o进行与子事务的冲突存取.这是为了保证一 个嵌套事务内部访问数据库的一致性.
　　（2） 兄弟事务或分属两个事务家族的事务之间的冲突按传统协议处理.
　　设有事务集T,对数据对象o和t∈T,令L(t,o,R),L(t,o,W),L(t,o)分别表示t持有o的读锁、写 锁和锁（不论读写）,事务的优先级记为pr(t).
　　并发控制协议可形式化地描述如下:
　　IF t′∈T(!L(t′,o))
　　　THENt锁住数据对象o
　　　ELSE IF t′∈T(!L(t′,o,w))∨t申请为对o的读锁
　　　　THEN t锁住o
　　　　ELSE IFt′∈T(！L(t′,o)∨R(t,t′)) /*所有锁住o的事务均为t的家族 事务*/
　　　　THEN IFt′∈T(！L(t′,o)∨P*(t,t′)) /*所有锁住o的事务均为t 的祖先事务*/
　　　　　THEN t继承对o的锁,t的祖先事务在t提交前不能访问o
　　　　ELSE
　　　　ABORT t
　　　ELSE IFt′∈T(L(t′,o)∨!R(t′,t)) /*不是所有锁住o的事务都是t 的家族事务*/
　　THEN IF t的优先级比所有锁住o的非家族事务的优先级都高
　　　　THEN 夭折所有锁住o的非家族事务
　　　　　IFt′∈T(L(t′,o)∨R(t′,t))
　　　　　　THEN IF t′∈T(!L(t′,o)∨p*(t,t′))
　　THEN t继承祖先事务的锁
　　　　ELSE ABORT t
　　ELSE t锁住o
　　ELSE ABORT t
　　定理1. 对于一个事务集T={t1,t2,...,tn},如果它执行并遵 守前述的结构依赖关系及并发控制协议,则事务是嵌套可串行化的.
证明:因为有子事务对父事务的夭折依赖关系,并且子事务对数据库的更 改只有到包含该子事务的根事务提交时才能真正反映到物理数据库,这就保证了一个事务集 执行的效果等同于一个可能执行集PES(T)的执行.而并发控制规则(1)保证了父子事务并发执 行时数据库的一致性,并发控制规则(2)保证了兄弟事务及两家族事务并发执行时数据库的一 致性.所以,事务集T的执行效果等同于PES(T)中事务的一个串行执行的效果,即事务执行是嵌 套可串行化的.
3 结束语
　　传统的原子事务模型对于事务和商务型的应用是有效的，而在实时应用环境下，事务间可能存在结构上的复杂性，这就要求我们提供复杂事务模型以适应实时应用的需求，本文在这方面的工作主要有：提出了一个嵌套事务的模型及其特性；给出了嵌套实时事务的优先级分派策略：针对事务嵌套的牲，提供了一种嵌套事务的并发控制协议。
　　在实时应用环境下,原子事务的优先级分派及事务的调度和并发控制已有较多的讨论.而在我 们的嵌套事务中,由于事务的嵌套结构特征使得事务的处理与传统原子事务相比有很大的差 别,如,基于事务嵌套特征的恢复就是一个复杂的问题,这些都是我们今后工作的研究重点.
　
本文研究得到国家自然科学基金和国防预研基金资助.
作者刘云生, 1940年生,教授,博士生导师,主要研究领域为现代（主动、实时、时序、内存等）数据库理 论与技术及其集成实现,数据库与信息系统开发及实时应用,软件方法学与支撑环境.
　　李国徽,1973年生,博士生,主要研究领域为主动、实时数据库系统及集成. 
本文通讯联系人:刘云生,武汉 430074,华中理工大学计算机科学与技术学院
作者单位：（华中理工大学计算机科学与技术学院 武汉　430074）
参考文献
　[1] 刘云生,胡国玲.实时数据库系统的正确性.计算机应用与软件,1995,12(6):1～8 
(Liu Yun-sheng, Hu Guo-ling. The correctness of real-time database sys tems. The Computer Application and Software, 1995,12(6):1～8)
　[2]刘云生,Ramamritham K,Stankovic J.关于实时数据库事务.软件学报,1995,6( 10):614～621
(Liu Yun-sheng, Ramamritham K, Stankovic J. About real-time database transacti ons. Journal of Software, 1995,6(10):614～621)
　[3] Abbott R K, Garcir-Molina H. Scheduling real-time transactions: a performance evaluation. ACM Transactions on Database Systems, 1992,17(3):513～560
本文1997-10-14收到原稿,1998-06-22收到修改稿
